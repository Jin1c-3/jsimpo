utils.load("test/inspector/wasm-inspector-test.js");let{session,contextGroup,Protocol}=InspectorTest.start("Tests how wasm scrips report the source");var builder=new WasmModuleBuilder;var imported_idx=builder.addImport("xxx","func",kSig_v_v);var call_imported_idx=builder.addFunction("call_func",kSig_v_v).addBody([kExprCallFunction,imported_idx]).index;var sig_index=builder.addType(kSig_v_v);builder.addFunction("main",kSig_v_v).addBody([kExprBlock,kWasmVoid,kExprI32Const,0,kExprCallIndirect,sig_index,kTableZero,kExprEnd]).exportAs("main");builder.appendToTable([call_imported_idx]);var module_bytes=builder.toArray();function testFunction(e){function t(){debugger}var r=new ArrayBuffer(e.length);var o=new Uint8Array(r);for(var s=0;s<e.length;s++){o[s]=e[s]|0}var n=new WebAssembly.Module(r);var i=new WebAssembly.Instance(n,{xxx:{func:t}});i.exports.main()}contextGroup.addScript(testFunction.toString());contextGroup.addScript("var module_bytes = "+JSON.stringify(module_bytes));Protocol.Debugger.enable();Protocol.Debugger.onPaused(handleDebuggerPaused);InspectorTest.log("Check that inspector gets wasm bytecode");Protocol.Runtime.evaluate({expression:"testFunction(module_bytes)"});async function handleDebuggerPaused(e){InspectorTest.log("Paused on debugger!");var n=e.params.callFrames;InspectorTest.log("Number of frames: "+n.length);async function t(r,o){if(o.error)InspectorTest.logObject(o);var e=o.result.scriptSource;var s=n[r].location.lineNumber;if(e){var t=e.split("\n")[s];InspectorTest.log("["+r+"] "+t)}else{if(s!=0){InspectorTest.log("Unexpected line number in wasm: "+s)}let e=n[r].location.columnNumber;let t=InspectorTest.decodeBase64(o.result.bytecode);InspectorTest.log("["+r+"] Wasm offset "+e+": 0x"+t[e].toString(16))}}for(let e=0;e<n.length;e++){result=await Protocol.Debugger.getScriptSource({scriptId:n[e].location.scriptId});await t(e,result)}InspectorTest.log("Finished.");InspectorTest.completeTest()}