"use strict";require("../common");const assert=require("assert");const util=require("util");function findInGraph(e,n,i){let r=0;for(let t=0;t<e.length;t++){const c=e[t];if(c.type===n)r++;if(r===i)return c}}function pruneTickObjects(e){const n={found:true,index:null,data:null};if(!Array.isArray(e))return e;while(n.found){for(let t=0;t<e.length;t++){if(e[t].type==="TickObject"){n.index=t;break}else if(t+1>=e.length){n.found=false}}if(n.found){n.data=e[n.index];const i={new:n.data.triggerAsyncId,old:n.data.uid};e.forEach(function t(e){if(e.triggerAsyncId===i.old)e.triggerAsyncId=i.new});e.splice(n.index,1)}}return e}module.exports=function t(e,i){pruneTickObjects(e);const r={};const c={};const s={};const o=[];const n=pruneTickObjects(e.activities);n.forEach(u);function u(t){if(!s[t.type])s[t.type]=0;s[t.type]++;const e=findInGraph(i,t.type,s[t.type]);if(e==null)return;r[e.id]=t.uid;c[t.uid]=e.id;if(e.triggerAsyncId==null)return;const n=r[e.triggerAsyncId];if(t.triggerAsyncId===n)return;o.push({id:e.id,expectedTid:e.triggerAsyncId,actualTid:c[t.triggerAsyncId]})}if(o.length){o.forEach(t=>console.error(`'${t.id}' expected to be triggered by '${t.expectedTid}', `+`but was triggered by '${t.actualTid}' instead.`))}assert.strictEqual(o.length,0);const d=Object.create(null);for(let t=0;t<i.length;t++){if(d[i[t].type]==null)d[i[t].type]=0;d[i[t].type]++}for(const l in d){assert.ok(s[l]>=d[l],`Type '${l}': expecting: ${d[l]} `+`found: ${s[l]}`)}};function inspect(t,e){console.error(util.inspect(t,false,e||5,true))}module.exports.printGraph=function t(e){const r={};const c={};const n=pruneTickObjects(e.activities);const s=[];n.forEach(i);function i(t){const e=t.type.replace(/WRAP/,"").toLowerCase();if(!r[e])r[e]=1;const n=`${e}:${r[e]++}`;c[t.uid]=n;const i=c[t.triggerAsyncId]||null;s.push({type:t.type,id:n,triggerAsyncId:i})}inspect(s)};