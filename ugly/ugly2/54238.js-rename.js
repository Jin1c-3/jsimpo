"use strict";const common=require("../common");if(!common.hasCrypto)common.skip("missing crypto");const assert=require("assert");const tls=require("tls");const CIPHERS="PSK+HIGH:TLS_AES_128_GCM_SHA256";const USERS={UserA:Buffer.allocUnsafe(128),UserB:Buffer.from("82072606b502b0f4025e90eb75fe137d","hex")};const TEST_DATA="x";const serverOptions={ciphers:CIPHERS,pskCallback(s,t){assert.ok(s instanceof tls.TLSSocket);assert.ok(typeof t==="string");return USERS[t]}};function test(e,o,n){const s=!n?common.mustCall(s=>{s.pipe(s)}):common.mustNotCall();const r=tls.createServer(serverOptions,s);r.listen(0,common.mustCall(()=>{const s={port:r.address().port,ciphers:CIPHERS,checkServerIdentity:()=>{},pskCallback:common.mustCall(()=>e),...o};if(!n){const t=tls.connect(s,common.mustCall(()=>{t.end(TEST_DATA);t.on("data",common.mustCall(s=>{assert.strictEqual(s.toString(),TEST_DATA)}));t.on("close",common.mustCall(()=>r.close()))}))}else{const t=tls.connect(s,common.mustNotCall());t.on("error",common.mustCall(s=>{assert.strictEqual(s.message,n);r.close()}))}}))}const DISCONNECT_MESSAGE="Client network socket disconnected before "+"secure TLS connection was established";test({psk:USERS.UserA,identity:"UserA"});test({psk:USERS.UserA,identity:"UserA"},{maxVersion:"TLSv1.2"});test({psk:USERS.UserA,identity:"UserA"},{minVersion:"TLSv1.3"});test({psk:USERS.UserB,identity:"UserB"});test({psk:USERS.UserB,identity:"UserB"},{minVersion:"TLSv1.3"});test({psk:USERS.UserB,identity:"UserC"},{},DISCONNECT_MESSAGE);test({psk:USERS.UserA,identity:"UserB"},{},DISCONNECT_MESSAGE);test({psk:USERS.UserB,identity:"UserB"});