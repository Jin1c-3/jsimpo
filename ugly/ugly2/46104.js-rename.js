import os from"os";import glob from"glob";import fs from"fs-extra";import execa from"execa";import cheerio from"cheerio";import{join,dirname,relative}from"path";import{version}from"next/package";import{recursiveReadDir}from"next/dist/lib/recursive-readdir";import{fetchViaHTTP,findPort,initNextServerScript,killApp,renderViaHTTP}from"next-test-utils";jest.setTimeout(1e3*60*2);const appDir=join(__dirname,"../app");const workDir=join(os.tmpdir(),`required-server-files-${Date.now()}`);let server;let nextApp;let appPort;let buildId;let requiredFilesManifest;let errors=[];describe("Required Server Files",()=>{beforeAll(async()=>{const e=await fs.readJSON(require.resolve("next/dist/server/next-server")+".nft.json");const t=dirname(require.resolve("next/package.json"));await execa("yarn",["pack"],{cwd:t});const a=join(t,`next-v${version}.tgz`);await fs.ensureDir(workDir);await fs.writeFile(join(workDir,"package.json"),JSON.stringify({dependencies:{next:a,react:"latest","react-dom":"latest"}}));await fs.copy(appDir,workDir);await execa("yarn",["install"],{cwd:workDir,stdio:["ignore","inherit","inherit"],env:{...process.env,YARN_CACHE_FOLDER:join(workDir,".yarn-cache")}});await execa("yarn",["next","build"],{cwd:workDir,stdio:["ignore","inherit","inherit"],env:{...process.env,NODE_ENV:"production",NOW_BUILDER:"1"}});buildId=await fs.readFile(join(workDir,".next/BUILD_ID"),"utf8");requiredFilesManifest=await fs.readJSON(join(workDir,".next/required-server-files.json"));await fs.ensureDir(`${workDir}-react`);await fs.writeFile(join(`${workDir}-react/package.json`),JSON.stringify({dependencies:{react:"latest","react-dom":"latest"}}));await execa("yarn",["install"],{cwd:`${workDir}-react`,stdio:["ignore","inherit","inherit"],env:{...process.env,YARN_CACHE_FOLDER:join(workDir,".yarn")}});await fs.remove(a);const o=await recursiveReadDir(workDir,/.*/);const r=await glob.sync("**/*.nft.json",{cwd:join(workDir,".next/server/pages")});const s=new Set;for(const i of r){const l=join(workDir,".next/server/pages",i);const p=await fs.readJSON(l);p.files.forEach(e=>s.add(relative(workDir,join(dirname(l),e))))}for(const i of o){const d=join("./",i);if(!e.files.includes(d)&&i!=="/node_modules/next/dist/server/next-server.js"&&!s.has(d)&&!requiredFilesManifest.files.includes(d)&&!d.startsWith(".next/server")&&d!==".next/required-server-files.json"){await fs.remove(join(workDir,i))}}for(const i of await fs.readdir(`${workDir}-react/node_modules`)){await fs.copy(join(`${workDir}-react/node_modules`,i),join(workDir,"node_modules",i))}await fs.remove(`${workDir}-react`);async function c(){const e=require("http");const t=require("next/dist/server/next-server").default;const o=process.env.PORT;nextApp=new t({conf:global.nextConfig,dir:process.env.APP_DIR,quiet:false,minimalMode:true});server=e.createServer(async(e,t)=>{try{await nextApp.getRequestHandler()(e,t)}catch(e){console.error("top-level",e);t.statusCode=500;t.end("error")}});await new Promise((t,a)=>{server.listen(o,e=>e?a(e):t())});console.log(`Listening at ::${o}`)}const n=join(workDir,"server.js");await fs.writeFile(n,"global.nextConfig = "+JSON.stringify(requiredFilesManifest.config)+";\n"+c.toString()+";\n"+`startServer().catch(console.error)`);appPort=await findPort();server=await initNextServerScript(n,/Listening at/,{...process.env,NODE_ENV:"production",PORT:appPort,APP_DIR:workDir},undefined,{cwd:workDir,onStderr(e){if(e.includes("top-level")){errors.push(e)}}})});afterAll(async()=>{if(server)killApp(server);await fs.remove(workDir)});it("should output required-server-files manifest correctly",async()=>{expect(requiredFilesManifest.version).toBe(1);expect(Array.isArray(requiredFilesManifest.files)).toBe(true);expect(Array.isArray(requiredFilesManifest.ignore)).toBe(true);expect(requiredFilesManifest.files.length).toBeGreaterThan(0);expect(requiredFilesManifest.ignore.length).toBeGreaterThan(0);expect(typeof requiredFilesManifest.config.configFile).toBe("undefined");expect(typeof requiredFilesManifest.config.trailingSlash).toBe("boolean");expect(typeof requiredFilesManifest.appDir).toBe("string");for(const e of requiredFilesManifest.files){expect(await fs.exists(join(workDir,e))).toBe(true)}expect(await fs.exists(join(workDir,".next/server"))).toBe(true)});it("should render SSR page correctly",async()=>{const e=await renderViaHTTP(appPort,"/");const t=cheerio.load(e);const a=JSON.parse(t("#props").text());expect(t("#index").text()).toBe("index page");expect(a.hello).toBe("world");const o=await renderViaHTTP(appPort,"/");const r=cheerio.load(o);const s=JSON.parse(r("#props").text());expect(r("#index").text()).toBe("index page");expect(isNaN(s.random)).toBe(false);expect(s.random).not.toBe(a.random)});it("should render dynamic SSR page correctly",async()=>{const e=await renderViaHTTP(appPort,"/dynamic/first");const t=cheerio.load(e);const a=JSON.parse(t("#props").text());expect(t("#dynamic").text()).toBe("dynamic page");expect(t("#slug").text()).toBe("first");expect(a.hello).toBe("world");const o=await renderViaHTTP(appPort,"/dynamic/second");const r=cheerio.load(o);const s=JSON.parse(r("#props").text());expect(r("#dynamic").text()).toBe("dynamic page");expect(r("#slug").text()).toBe("second");expect(isNaN(s.random)).toBe(false);expect(s.random).not.toBe(a.random)});it("should render fallback page correctly",async()=>{const e=await renderViaHTTP(appPort,"/fallback/first");const t=cheerio.load(e);const a=JSON.parse(t("#props").text());expect(t("#fallback").text()).toBe("fallback page");expect(t("#slug").text()).toBe("first");expect(a.hello).toBe("world");const o=await renderViaHTTP(appPort,"/fallback/first");const r=cheerio.load(o);const s=JSON.parse(r("#props").text());expect(r("#fallback").text()).toBe("fallback page");expect(r("#slug").text()).toBe("first");expect(isNaN(s.random)).toBe(false);expect(s.random).not.toBe(a.random);const c=await renderViaHTTP(appPort,"/fallback/second");const n=cheerio.load(c);const i=JSON.parse(n("#props").text());expect(n("#fallback").text()).toBe("fallback page");expect(n("#slug").text()).toBe("second");expect(isNaN(i.random)).toBe(false);const{pageProps:l}=JSON.parse(await renderViaHTTP(appPort,`/_next/data/${buildId}/fallback/third.json`));expect(l.hello).toBe("world");expect(l.slug).toBe("third")});it("should render SSR page correctly with x-matched-path",async()=>{const e=await renderViaHTTP(appPort,"/some-other-path",undefined,{headers:{"x-matched-path":"/"}});const t=cheerio.load(e);const a=JSON.parse(t("#props").text());expect(t("#index").text()).toBe("index page");expect(a.hello).toBe("world");const o=await renderViaHTTP(appPort,"/some-other-path",undefined,{headers:{"x-matched-path":"/"}});const r=cheerio.load(o);const s=JSON.parse(r("#props").text());expect(r("#index").text()).toBe("index page");expect(isNaN(s.random)).toBe(false);expect(s.random).not.toBe(a.random)});it("should render dynamic SSR page correctly with x-matched-path",async()=>{const e=await renderViaHTTP(appPort,"/some-other-path",undefined,{headers:{"x-matched-path":"/dynamic/[slug]?slug=first"}});const t=cheerio.load(e);const a=JSON.parse(t("#props").text());expect(t("#dynamic").text()).toBe("dynamic page");expect(t("#slug").text()).toBe("first");expect(a.hello).toBe("world");const o=await renderViaHTTP(appPort,"/some-other-path",undefined,{headers:{"x-matched-path":"/dynamic/[slug]?slug=second"}});const r=cheerio.load(o);const s=JSON.parse(r("#props").text());expect(r("#dynamic").text()).toBe("dynamic page");expect(r("#slug").text()).toBe("second");expect(isNaN(s.random)).toBe(false);expect(s.random).not.toBe(a.random);const c=await renderViaHTTP(appPort,"/some-other-path",undefined,{headers:{"x-matched-path":"/dynamic/[slug]?slug=%5Bslug%5D.json","x-now-route-matches":"1=second&slug=second"}});const n=cheerio.load(c);const i=JSON.parse(n("#props").text());expect(n("#dynamic").text()).toBe("dynamic page");expect(n("#slug").text()).toBe("second");expect(isNaN(i.random)).toBe(false);expect(i.random).not.toBe(a.random)});it("should render fallback page correctly with x-matched-path and routes-matches",async()=>{const e=await renderViaHTTP(appPort,"/fallback/first",undefined,{headers:{"x-matched-path":"/fallback/first","x-now-route-matches":"1=first"}});const t=cheerio.load(e);const a=JSON.parse(t("#props").text());expect(t("#fallback").text()).toBe("fallback page");expect(t("#slug").text()).toBe("first");expect(a.hello).toBe("world");const o=await renderViaHTTP(appPort,`/fallback/[slug]`,undefined,{headers:{"x-matched-path":"/fallback/[slug]","x-now-route-matches":"1=second"}});const r=cheerio.load(o);const s=JSON.parse(r("#props").text());expect(r("#fallback").text()).toBe("fallback page");expect(r("#slug").text()).toBe("second");expect(isNaN(s.random)).toBe(false);expect(s.random).not.toBe(a.random)});it("should return data correctly with x-matched-path",async()=>{const e=await fetchViaHTTP(appPort,`/_next/data/${buildId}/dynamic/first.json`,undefined,{headers:{"x-matched-path":"/dynamic/[slug]?slug=first"}});const{pageProps:t}=await e.json();expect(t.slug).toBe("first");expect(t.hello).toBe("world");const a=await fetchViaHTTP(appPort,`/_next/data/${buildId}/fallback/[slug].json`,undefined,{headers:{"x-matched-path":`/_next/data/${buildId}/fallback/[slug].json`,"x-now-route-matches":"1=second"}});const{pageProps:o}=await a.json();expect(o.slug).toBe("second");expect(o.hello).toBe("world")});it("should render fallback optional catch-all route correctly with x-matched-path and routes-matches",async()=>{const e=await renderViaHTTP(appPort,"/catch-all/[[...rest]]",undefined,{headers:{"x-matched-path":"/catch-all/[[...rest]]","x-now-route-matches":""}});const t=cheerio.load(e);const a=JSON.parse(t("#props").text());expect(t("#catch-all").text()).toBe("optional catch-all page");expect(a.params).toEqual({});expect(a.hello).toBe("world");const o=await renderViaHTTP(appPort,"/catch-all/[[...rest]]",undefined,{headers:{"x-matched-path":"/catch-all/[[...rest]]","x-now-route-matches":"1=hello&catchAll=hello"}});const r=cheerio.load(o);const s=JSON.parse(r("#props").text());expect(r("#catch-all").text()).toBe("optional catch-all page");expect(s.params).toEqual({rest:["hello"]});expect(isNaN(s.random)).toBe(false);expect(s.random).not.toBe(a.random);const c=await renderViaHTTP(appPort,"/catch-all/[[..rest]]",undefined,{headers:{"x-matched-path":"/catch-all/[[...rest]]","x-now-route-matches":"1=hello/world&catchAll=hello/world"}});const n=cheerio.load(c);const i=JSON.parse(n("#props").text());expect(n("#catch-all").text()).toBe("optional catch-all page");expect(i.params).toEqual({rest:["hello","world"]});expect(isNaN(i.random)).toBe(false);expect(i.random).not.toBe(a.random)});it("should return data correctly with x-matched-path for optional catch-all route",async()=>{const e=await fetchViaHTTP(appPort,`/_next/data/${buildId}/catch-all.json`,undefined,{headers:{"x-matched-path":"/catch-all/[[...rest]]"}});const{pageProps:t}=await e.json();expect(t.params).toEqual({});expect(t.hello).toBe("world");const a=await fetchViaHTTP(appPort,`/_next/data/${buildId}/catch-all/[[...rest]].json`,undefined,{headers:{"x-matched-path":`/_next/data/${buildId}/catch-all/[[...rest]].json`,"x-now-route-matches":"1=hello&rest=hello"}});const{pageProps:o}=await a.json();expect(o.params).toEqual({rest:["hello"]});expect(o.hello).toBe("world");const r=await fetchViaHTTP(appPort,`/_next/data/${buildId}/catch-all/[[...rest]].json`,undefined,{headers:{"x-matched-path":`/_next/data/${buildId}/catch-all/[[...rest]].json`,"x-now-route-matches":"1=hello/world&rest=hello/world"}});const{pageProps:s}=await r.json();expect(s.params).toEqual({rest:["hello","world"]});expect(s.hello).toBe("world")});it("should not apply trailingSlash redirect",async()=>{for(const e of["/","/dynamic/another/","/dynamic/another","/fallback/first/","/fallback/first","/fallback/another/","/fallback/another"]){const t=await fetchViaHTTP(appPort,e,undefined,{redirect:"manual"});expect(t.status).toBe(200)}});it("should normalize catch-all rewrite query values correctly",async()=>{const e=await renderViaHTTP(appPort,"/some-catch-all/hello/world",{path:"hello/world"},{headers:{"x-matched-path":"/"}});const t=cheerio.load(e);expect(JSON.parse(t("#router").text()).query).toEqual({path:["hello","world"]})});it("should bubble error correctly for gip page",async()=>{errors=[];const e=await fetchViaHTTP(appPort,"/errors/gip",{crash:"1"});expect(e.status).toBe(500);expect(await e.text()).toBe("error");expect(errors.length).toBe(1);expect(errors[0]).toContain("gip hit an oops")});it("should bubble error correctly for gssp page",async()=>{errors=[];const e=await fetchViaHTTP(appPort,"/errors/gssp",{crash:"1"});expect(e.status).toBe(500);expect(await e.text()).toBe("error");expect(errors.length).toBe(1);expect(errors[0]).toContain("gssp hit an oops")});it("should bubble error correctly for gsp page",async()=>{errors=[];const e=await fetchViaHTTP(appPort,"/errors/gsp/crash");expect(e.status).toBe(500);expect(await e.text()).toBe("error");expect(errors.length).toBe(1);expect(errors[0]).toContain("gsp hit an oops")});it("should bubble error correctly for API page",async()=>{errors=[];const e=await fetchViaHTTP(appPort,"/api/error");expect(e.status).toBe(500);expect(await e.text()).toBe("error");expect(errors.length).toBe(1);expect(errors[0]).toContain("some error from /api/error")});it("should normalize optional values correctly for SSP page",async()=>{const e=await fetchViaHTTP(appPort,"/optional-ssp",{rest:"",another:"value"},{headers:{"x-matched-path":"/optional-ssp/[[...rest]]"}});const t=await e.text();const a=cheerio.load(t);const o=JSON.parse(a("#props").text());expect(o.params).toEqual({});expect(o.query).toEqual({another:"value"})});it("should normalize optional values correctly for SSG page",async()=>{const e=await fetchViaHTTP(appPort,"/optional-ssg",{rest:"",another:"value"},{headers:{"x-matched-path":"/optional-ssg/[[...rest]]"}});const t=await e.text();const a=cheerio.load(t);const o=JSON.parse(a("#props").text());expect(o.params).toEqual({})});it("should normalize optional values correctly for SSG page with encoded slash",async()=>{const e=await fetchViaHTTP(appPort,"/optional-ssg/[[...rest]]",undefined,{headers:{"x-matched-path":"/optional-ssg/[[...rest]]","x-now-route-matches":"1=en%2Fes%2Fhello%252Fworld&rest=en%2Fes%2Fhello%252Fworld"}});const t=await e.text();const a=cheerio.load(t);const o=JSON.parse(a("#props").text());expect(o.params).toEqual({rest:["en","es","hello/world"]})});it("should normalize optional values correctly for API page",async()=>{const e=await fetchViaHTTP(appPort,"/api/optional",{rest:"",another:"value"},{headers:{"x-matched-path":"/api/optional/[[...rest]]"}});const t=await e.json();expect(t.query).toEqual({another:"value"});expect(t.url).toBe("/api/optional?another=value")});it("should match the index page correctly",async()=>{const e=await fetchViaHTTP(appPort,"/",undefined,{headers:{"x-matched-path":"/index"},redirect:"manual"});const t=await e.text();const a=cheerio.load(t);expect(a("#index").text()).toBe("index page")});it("should match the root dyanmic page correctly",async()=>{const e=await fetchViaHTTP(appPort,"/index",undefined,{headers:{"x-matched-path":"/[slug]"},redirect:"manual"});const t=await e.text();const a=cheerio.load(t);expect(a("#slug-page").text()).toBe("[slug] page")})});