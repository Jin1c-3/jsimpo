import{log}from"../logger";import graphlib from"graphlib";export let clusterDb={};let decendants={};let parents={};export const clear=()=>{decendants={};parents={};clusterDb={}};const isDecendant=(e,t)=>{log.trace("In isDecendant",t," ",e," = ",decendants[t].indexOf(e)>=0);if(decendants[t].indexOf(e)>=0)return true;return false};const edgeInCluster=(e,t)=>{log.info("Decendants of ",t," is ",decendants[t]);log.info("Edge is ",e);if(e.v===t)return false;if(e.w===t)return false;if(!decendants[t]){log.debug("Tilt, ",t,",not in decendants");return false}log.info("Here ");if(decendants[t].indexOf(e.v)>=0)return true;if(isDecendant(e.v,t))return true;if(isDecendant(e.w,t))return true;if(decendants[t].indexOf(e.w)>=0)return true;return false};const copy=(r,o,l,s)=>{log.warn("Copying children of ",r,"root",s,"data",o.node(r),s);const e=o.children(r)||[];if(r!==s){e.push(r)}log.warn("Copying (nodes) clusterId",r,"nodes",e);e.forEach(e=>{if(o.children(e).length>0){copy(e,o,l,s)}else{const t=o.node(e);log.info("cp ",e," to ",s," with parent ",r);l.setNode(e,t);if(s!==o.parent(e)){log.warn("Setting parent",e,o.parent(e));l.setParent(e,o.parent(e))}if(r!==s&&e!==r){log.debug("Setting parent",e,r);l.setParent(e,r)}else{log.info("In copy ",r,"root",s,"data",o.node(r),s);log.debug("Not Setting parent for node=",e,"cluster!==rootId",r!==s,"node!==clusterId",e!==r)}const n=o.edges(e);log.debug("Copying Edges",n);n.forEach(e=>{log.info("Edge",e);const t=o.edge(e.v,e.w,e.name);log.info("Edge data",t,s);try{if(edgeInCluster(e,s)){log.info("Copying as ",e.v,e.w,t,e.name);l.setEdge(e.v,e.w,t,e.name);log.info("newGraph edges ",l.edges(),l.edge(l.edges()[0]))}else{log.info("Skipping copy of edge ",e.v,"--\x3e",e.w," rootId: ",s," clusterId:",r)}}catch(e){log.error(e)}})}log.debug("Removing node",e);o.removeNode(e)})};export const extractDecendants=(t,n)=>{const r=n.children(t);let o=[].concat(r);for(let e=0;e<r.length;e++){parents[r[e]]=t;o=o.concat(extractDecendants(r[e],n))}return o};export const validate=t=>{const n=t.edges();log.trace("Edges: ",n);for(let e=0;e<n.length;e++){if(t.children(n[e].v).length>0){log.trace("The node ",n[e].v," is part of and edge even though it has children");return false}if(t.children(n[e].w).length>0){log.trace("The node ",n[e].w," is part of and edge even though it has children");return false}}return true};export const findNonClusterChild=(t,n)=>{log.trace("Searching",t);const r=n.children(t);log.trace("Searching children of id ",t,r);if(r.length<1){log.trace("This is a valid node",t);return t}for(let e=0;e<r.length;e++){const o=findNonClusterChild(r[e],n);if(o){log.trace("Found replacement for",t," => ",o);return o}}};const getAnchorId=e=>{if(!clusterDb[e]){return e}if(!clusterDb[e].externalConnections){return e}if(clusterDb[e]){return clusterDb[e].id}return e};export const adjustClustersAndEdges=(o,e)=>{if(!o||e>10){log.debug("Opting out, no graph ");return}else{log.debug("Opting in, graph ")}o.nodes().forEach(function(e){const t=o.children(e);if(t.length>0){log.warn("Cluster identified",e," Replacement id in edges: ",findNonClusterChild(e,o));decendants[e]=extractDecendants(e,o);clusterDb[e]={id:findNonClusterChild(e,o),clusterData:o.node(e)}}});o.nodes().forEach(function(r){const e=o.children(r);const t=o.edges();if(e.length>0){log.debug("Cluster identified",r,decendants);t.forEach(e=>{if(e.v!==r&&e.w!==r){const t=isDecendant(e.v,r);const n=isDecendant(e.w,r);if(t^n){log.warn("Edge: ",e," leaves cluster ",r);log.warn("Decendants of XXX ",r,": ",decendants[r]);clusterDb[r].externalConnections=true}}})}else{log.debug("Not a cluster ",r,decendants)}});o.edges().forEach(function(e){const t=o.edge(e);log.warn("Edge "+e.v+" -> "+e.w+": "+JSON.stringify(e));log.warn("Edge "+e.v+" -> "+e.w+": "+JSON.stringify(o.edge(e)));let n=e.v;let r=e.w;log.warn("Fix XXX",clusterDb,"ids:",e.v,e.w,"Translateing: ",clusterDb[e.v]," --- ",clusterDb[e.w]);if(clusterDb[e.v]||clusterDb[e.w]){log.warn("Fixing and trixing - removing XXX",e.v,e.w,e.name);n=getAnchorId(e.v);r=getAnchorId(e.w);o.removeEdge(e.v,e.w,e.name);if(n!==e.v)t.fromCluster=e.v;if(r!==e.w)t.toCluster=e.w;log.warn("Fix Replacing with XXX",n,r,e.name);o.setEdge(n,r,t,e.name)}});log.warn("Adjusted Graph",graphlib.json.write(o));extractor(o,0);log.trace(clusterDb)};export const extractor=(t,n)=>{log.warn("extractor - ",n,graphlib.json.write(t),t.children("D"));if(n>10){log.error("Bailing out");return}let r=t.nodes();let o=false;for(let e=0;e<r.length;e++){const l=r[e];const s=t.children(l);o=o||s.length>0}if(!o){log.debug("Done, no node has children",t.nodes());return}log.debug("Nodes = ",r,n);for(let e=0;e<r.length;e++){const l=r[e];log.debug("Extracting node",l,clusterDb,clusterDb[l]&&!clusterDb[l].externalConnections,!t.parent(l),t.node(l),t.children("D")," Depth ",n);if(!clusterDb[l]){log.debug("Not a cluster",l,n)}else if(!clusterDb[l].externalConnections&&t.children(l)&&t.children(l).length>0){log.warn("Cluster without external connections, without a parent and with children",l,n);const c=t.graph();let e=c.rankdir==="TB"?"LR":"TB";if(clusterDb[l]){if(clusterDb[l].clusterData&&clusterDb[l].clusterData.dir){e=clusterDb[l].clusterData.dir;log.warn("Fixing dir",clusterDb[l].clusterData.dir,e)}}const a=new graphlib.Graph({multigraph:true,compound:true}).setGraph({rankdir:e,nodesep:50,ranksep:50,marginx:8,marginy:8}).setDefaultEdgeLabel(function(){return{}});log.warn("Old graph before copy",graphlib.json.write(t));copy(l,t,a,l);t.setNode(l,{clusterNode:true,id:l,clusterData:clusterDb[l].clusterData,labelText:clusterDb[l].labelText,graph:a});log.warn("New graph after copy node: (",l,")",graphlib.json.write(a));log.debug("Old graph after copy",graphlib.json.write(t))}else{log.warn("Cluster ** ",l," **not meeting the criteria !externalConnections:",!clusterDb[l].externalConnections," no parent: ",!t.parent(l)," children ",t.children(l)&&t.children(l).length>0,t.children("D"),n);log.debug(clusterDb)}}r=t.nodes();log.warn("New list of nodes",r);for(let e=0;e<r.length;e++){const l=r[e];const i=t.node(l);log.warn(" Now next level",l,i);if(i.clusterNode){extractor(i.graph,n+1)}}};const sorter=(r,e)=>{if(e.length===0)return[];let o=Object.assign(e);e.forEach(e=>{const t=r.children(e);const n=sorter(r,t);o=o.concat(n)});return o};export const sortNodesByHierarchy=e=>sorter(e,e.children());