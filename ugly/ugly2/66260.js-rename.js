module.exports={read:read,readSSHPrivate:readSSHPrivate,write:write};var assert=require("assert-plus");var asn1=require("asn1");var Buffer=require("safer-buffer").Buffer;var algs=require("../algs");var utils=require("../utils");var crypto=require("crypto");var Key=require("../key");var PrivateKey=require("../private-key");var pem=require("./pem");var rfc4253=require("./rfc4253");var SSHBuffer=require("../ssh-buffer");var errors=require("../errors");var bcrypt;function read(r,e){return pem.read(r,e)}var MAGIC="openssh-key-v1";function readSSHPrivate(r,e,t){e=new SSHBuffer({buffer:e});var a=e.readCString();assert.strictEqual(a,MAGIC,"bad magic string");var i=e.readString();var n=e.readString();var f=e.readBuffer();var s=e.readInt();if(s!==1){throw new Error("OpenSSH-format key file contains "+"multiple keys: this is unsupported.")}var o=e.readBuffer();if(r==="public"){assert.ok(e.atEnd(),"excess bytes left after key");return rfc4253.read(o)}var u=e.readBuffer();assert.ok(e.atEnd(),"excess bytes left after key");var p=new SSHBuffer({buffer:f});switch(n){case"none":if(i!=="none"){throw new Error('OpenSSH-format key uses KDF "none" '+'but specifies a cipher other than "none"')}break;case"bcrypt":var c=p.readBuffer();var v=p.readInt();var d=utils.opensshCipherInfo(i);if(bcrypt===undefined){bcrypt=require("bcrypt-pbkdf")}if(typeof t.passphrase==="string"){t.passphrase=Buffer.from(t.passphrase,"utf-8")}if(!Buffer.isBuffer(t.passphrase)){throw new errors.KeyEncryptedError(t.filename,"OpenSSH")}var l=new Uint8Array(t.passphrase);var y=new Uint8Array(c);var w=new Uint8Array(d.keySize+d.blockSize);var S=bcrypt.pbkdf(l,l.length,y,y.length,w,w.length,v);if(S!==0){throw new Error("bcrypt_pbkdf function returned "+"failure, parameters invalid")}w=Buffer.from(w);var h=w.slice(0,d.keySize);var b=w.slice(d.keySize,d.keySize+d.blockSize);var k=crypto.createDecipheriv(d.opensslName,h,b);k.setAutoPadding(false);var B,g=[];k.once("error",function(r){if(r.toString().indexOf("bad decrypt")!==-1){throw new Error("Incorrect passphrase "+"supplied, could not decrypt key")}throw r});k.write(u);k.end();while((B=k.read())!==null)g.push(B);u=Buffer.concat(g);break;default:throw new Error('OpenSSH-format key uses unknown KDF "'+n+'"')}e=new SSHBuffer({buffer:u});var m=e.readInt();var E=e.readInt();if(m!==E){throw new Error("Incorrect passphrase supplied, could not "+"decrypt key")}var I={};var P=rfc4253.readInternal(I,"private",e.remainder());e.skip(I.consumed);var H=e.readString();P.comment=H;return P}function write(r,e){var t;if(PrivateKey.isPrivateKey(r))t=r.toPublic();else t=r;var a="none";var i="none";var n=Buffer.alloc(0);var f={blockSize:8};var s;if(e!==undefined){s=e.passphrase;if(typeof s==="string")s=Buffer.from(s,"utf-8");if(s!==undefined){assert.buffer(s,"options.passphrase");assert.optionalString(e.cipher,"options.cipher");a=e.cipher;if(a===undefined)a="aes128-ctr";f=utils.opensshCipherInfo(a);i="bcrypt"}}var o;if(PrivateKey.isPrivateKey(r)){o=new SSHBuffer({});var u=crypto.randomBytes(4).readUInt32BE(0);o.writeInt(u);o.writeInt(u);o.write(r.toBuffer("rfc4253"));o.writeString(r.comment||"");var p=1;while(o._offset%f.blockSize!==0)o.writeChar(p++);o=o.toBuffer()}switch(i){case"none":break;case"bcrypt":var c=crypto.randomBytes(16);var v=16;var d=new SSHBuffer({});d.writeBuffer(c);d.writeInt(v);n=d.toBuffer();if(bcrypt===undefined){bcrypt=require("bcrypt-pbkdf")}var l=new Uint8Array(s);var y=new Uint8Array(c);var w=new Uint8Array(f.keySize+f.blockSize);var S=bcrypt.pbkdf(l,l.length,y,y.length,w,w.length,v);if(S!==0){throw new Error("bcrypt_pbkdf function returned "+"failure, parameters invalid")}w=Buffer.from(w);var h=w.slice(0,f.keySize);var b=w.slice(f.keySize,f.keySize+f.blockSize);var k=crypto.createCipheriv(f.opensslName,h,b);k.setAutoPadding(false);var B,g=[];k.once("error",function(r){throw r});k.write(o);k.end();while((B=k.read())!==null)g.push(B);o=Buffer.concat(g);break;default:throw new Error("Unsupported kdf "+i)}var m=new SSHBuffer({});m.writeCString(MAGIC);m.writeString(a);m.writeString(i);m.writeBuffer(n);m.writeInt(1);m.writeBuffer(t.toBuffer("rfc4253"));if(o)m.writeBuffer(o);m=m.toBuffer();var E;if(PrivateKey.isPrivateKey(r))E="OPENSSH PRIVATE KEY";else E="OPENSSH PUBLIC KEY";var I=m.toString("base64");var P=I.length+I.length/70+18+16+E.length*2+10;m=Buffer.alloc(P);var H=0;H+=m.write("-----BEGIN "+E+"-----\n",H);for(var q=0;q<I.length;){var z=q+70;if(z>I.length)z=I.length;H+=m.write(I.slice(q,z),H);m[H++]=10;q=z}H+=m.write("-----END "+E+"-----\n",H);return m.slice(0,H)}