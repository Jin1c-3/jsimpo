"use strict";const crypto=require("crypto");const fs=require("fs");const path=require("path");const globby=require("globby");const sandbox=require("sinon");const chai=require("chai");const proxyquire=require("proxyquire");const normalizeFiles=require("../../../../../../../lib/plugins/aws/lib/normalizeFiles");const AwsProvider=require("../../../../../../../lib/plugins/aws/provider");const AwsDeploy=require("../../../../../../../lib/plugins/aws/deploy/index");const Serverless=require("../../../../../../../lib/Serverless");const ServerlessError=require("../../../../../../../lib/serverless-error");const runServerless=require("../../../../../../utils/run-serverless");chai.use(require("chai-as-promised"));chai.use(require("sinon-chai"));const expect=require("chai").expect;describe("checkForChanges",()=>{let s;let a;let n;let o;let i;beforeEach(()=>{const e={stage:"dev",region:"us-east-1"};s=new Serverless;s.serviceDir="my-service";a=new AwsProvider(s,e);s.setProvider("aws",a);s.service.service="my-service";n=new AwsDeploy(s,e);n.bucketName="deployment-bucket";n.serverless.service.provider.compiledCloudFormationTemplate={foo:"bar"};o=`serverless/${s.service.service}/${a.getStage()}`;n.serverless.cli={log:sandbox.spy()};i={createHash(){return this},update(){return this},digest:sandbox.stub()};const t=proxyquire("../../../../../../../lib/plugins/aws/deploy/lib/checkForChanges.js",{crypto:i});Object.assign(n,t)});describe("#checkForChanges()",()=>{let e;let t;let s;let a;beforeEach(()=>{e=sandbox.stub(n,"getMostRecentObjects").resolves();t=sandbox.stub(n,"getObjectMetadata").resolves();s=sandbox.stub(n,"checkIfDeploymentIsNecessary").resolves();a=sandbox.stub(n,"checkLogGroupSubscriptionFilterResourceLimitExceeded").resolves()});afterEach(()=>{n.getMostRecentObjects.restore();n.getObjectMetadata.restore();n.checkIfDeploymentIsNecessary.restore();n.checkLogGroupSubscriptionFilterResourceLimitExceeded.restore();a.restore()});it('should resolve if the "force" option is used',()=>{n.options.force=true;return expect(n.checkForChanges()).to.be.fulfilled.then(()=>{expect(e).to.not.have.been.called;expect(t).to.not.have.been.called;expect(s).to.not.have.been.called;expect(n.serverless.service.provider.shouldNotDeploy).to.equal(false)})})});describe("#getMostRecentObjects()",()=>{let t;beforeEach(()=>{t=sandbox.stub(n.provider,"request")});afterEach(()=>{n.provider.request.restore()});it("should resolve if no result is returned",()=>{t.resolves();return expect(n.getMostRecentObjects()).to.be.fulfilled.then(e=>{expect(t).to.have.been.calledWithExactly("S3","listObjectsV2",{Bucket:n.bucketName,Prefix:"serverless/my-service/dev"});expect(e).to.deep.equal([])})});it("should translate error if rejected due to missing bucket",()=>{t.rejects(new ServerlessError("The specified bucket does not exist"));return expect(n.getMostRecentObjects()).to.be.rejectedWith([`The serverless deployment bucket "${n.bucketName}" does not exist.`,'Create it manually if you want to reuse the CloudFormation stack "my-service-dev",',"or delete the stack if it is no longer required."].join(" "))});it("should throw original error if rejected not due to missing bucket",()=>{t.rejects(new ServerlessError("Other reason"));return expect(n.getMostRecentObjects()).to.be.rejectedWith("Other reason")});it("should resolve if result array is empty",()=>{const e={Contents:[]};t.resolves(e);return expect(n.getMostRecentObjects()).to.be.fulfilled.then(e=>{expect(t).to.have.been.calledWithExactly("S3","listObjectsV2",{Bucket:n.bucketName,Prefix:"serverless/my-service/dev"});expect(e).to.deep.equal([])})});it("should resolve with the most recently deployed objects",()=>{const e={Contents:[{Key:`${o}/151224711231-2016-08-18T15:43:00/artifact.zip`},{Key:`${o}/151224711231-2016-08-18T15:43:00/cloudformation.json`},{Key:`${o}/141264711231-2016-08-18T15:42:00/artifact.zip`},{Key:`${o}/141264711231-2016-08-18T15:42:00/cloudformation.json`}]};t.resolves(e);return expect(n.getMostRecentObjects()).to.be.fulfilled.then(e=>{expect(t).to.have.been.calledWithExactly("S3","listObjectsV2",{Bucket:n.bucketName,Prefix:"serverless/my-service/dev"});expect(e).to.deep.equal([{Key:`${o}/151224711231-2016-08-18T15:43:00/cloudformation.json`},{Key:`${o}/151224711231-2016-08-18T15:43:00/artifact.zip`}])})})});describe("#getObjectMetadata()",()=>{let t;beforeEach(()=>{t=sandbox.stub(n.provider,"request").resolves()});afterEach(()=>{n.provider.request.restore()});it("should resolve if no input is provided",()=>expect(n.getObjectMetadata()).to.be.fulfilled.then(e=>{expect(t).to.not.have.been.called;expect(e).to.deep.equal([])}));it("should resolve if no objects are provided as input",()=>{const e=[];return expect(n.getObjectMetadata(e)).to.be.fulfilled.then(e=>{expect(t).to.not.have.been.called;expect(e).to.deep.equal([])})});it("should request the object detailed information",()=>{const e=[{Key:`${o}/151224711231-2016-08-18T15:43:00/artifact.zip`},{Key:`${o}/151224711231-2016-08-18T15:43:00/cloudformation.json`},{Key:`${o}/141264711231-2016-08-18T15:42:00/artifact.zip`},{Key:`${o}/141264711231-2016-08-18T15:42:00/cloudformation.json`}];return expect(n.getObjectMetadata(e)).to.be.fulfilled.then(()=>{expect(t.callCount).to.equal(4);expect(t).to.have.been.calledWithExactly("S3","headObject",{Bucket:n.bucketName,Key:`${o}/151224711231-2016-08-18T15:43:00/artifact.zip`});expect(t).to.have.been.calledWithExactly("S3","headObject",{Bucket:n.bucketName,Key:`${o}/151224711231-2016-08-18T15:43:00/cloudformation.json`});expect(t).to.have.been.calledWithExactly("S3","headObject",{Bucket:n.bucketName,Key:`${o}/141264711231-2016-08-18T15:42:00/artifact.zip`});expect(t).to.have.been.calledWithExactly("S3","headObject",{Bucket:n.bucketName,Key:`${o}/141264711231-2016-08-18T15:42:00/cloudformation.json`})})})});describe("#checkIfDeploymentIsNecessary()",()=>{let o;let c;let r;beforeEach(()=>{o=sandbox.stub(normalizeFiles,"normalizeCloudFormationTemplate").returns();c=sandbox.stub(globby,"sync");r=sandbox.stub(fs,"readFile").yields(null,undefined)});afterEach(()=>{normalizeFiles.normalizeCloudFormationTemplate.restore();globby.sync.restore();fs.readFile.restore()});it("should resolve if no input is provided",()=>expect(n.checkIfDeploymentIsNecessary()).to.be.fulfilled.then(()=>{expect(o).to.not.have.been.called;expect(c).to.not.have.been.called;expect(r).to.not.have.been.called;expect(n.serverless.cli.log).to.not.have.been.called}));it("should resolve if no objects are provided as input",()=>{const e=[];return expect(n.checkIfDeploymentIsNecessary(e)).to.be.fulfilled.then(()=>{expect(o).to.not.have.been.called;expect(c).to.not.have.been.called;expect(r).to.not.have.been.called;expect(n.serverless.cli.log).to.not.have.been.called})});it("should resolve if objects are given, but no function last modified date",()=>{c.returns(["my-service.zip"]);i.createHash().update().digest.onCall(0).returns("local-hash-cf-template");const e=[{Metadata:{filesha256:"remote-hash-cf-template"}}];return expect(n.checkIfDeploymentIsNecessary(e)).to.be.fulfilled.then(()=>{expect(o).to.have.been.calledOnce;expect(c).to.have.been.calledOnce;expect(r).to.have.been.calledOnce;expect(n.serverless.cli.log).to.not.have.been.called;expect(o).to.have.been.calledWithExactly(n.serverless.service.provider.compiledCloudFormationTemplate);expect(c).to.have.been.calledWithExactly(["**.zip"],{cwd:path.join(n.serverless.serviceDir,".serverless"),dot:true,silent:true});expect(r).to.have.been.calledWith(path.resolve(n.serverless.serviceDir,".serverless/my-service.zip"));expect(n.serverless.service.provider.shouldNotDeploy).to.equal(undefined)})});it("should not set a flag if there are more remote hashes",()=>{c.returns(["my-service.zip"]);i.createHash().update().digest.onCall(0).returns("local-hash-cf-template");i.createHash().update().digest.onCall(1).returns("local-hash-zip-file-1");const e=[{Metadata:{filesha256:"remote-hash-cf-template"}},{Metadata:{filesha256:"remote-hash-zip-file-1"}},{Metadata:{}}];return expect(n.checkIfDeploymentIsNecessary(e)).to.be.fulfilled.then(()=>{expect(o).to.have.been.calledOnce;expect(c).to.have.been.calledOnce;expect(r).to.have.been.calledOnce;expect(n.serverless.cli.log).to.not.have.been.called;expect(o).to.have.been.calledWithExactly(n.serverless.service.provider.compiledCloudFormationTemplate);expect(c).to.have.been.calledWithExactly(["**.zip"],{cwd:path.join(n.serverless.serviceDir,".serverless"),dot:true,silent:true});expect(r).to.have.been.calledWith(path.resolve(n.serverless.serviceDir,".serverless/my-service.zip"));expect(n.serverless.service.provider.shouldNotDeploy).to.equal(undefined)})});it("should not set a flag if remote and local hashes are different",()=>{c.returns(["my-service.zip"]);i.createHash().update().digest.onCall(0).returns("local-hash-cf-template");i.createHash().update().digest.onCall(1).returns("local-hash-zip-file-1");const e=[{Metadata:{filesha256:"remote-hash-cf-template"}},{Metadata:{filesha256:"remote-hash-zip-file-1"}}];return expect(n.checkIfDeploymentIsNecessary(e)).to.be.fulfilled.then(()=>{expect(o).to.have.been.calledOnce;expect(c).to.have.been.calledOnce;expect(r).to.have.been.calledOnce;expect(n.serverless.cli.log).to.not.have.been.called;expect(o).to.have.been.calledWithExactly(n.serverless.service.provider.compiledCloudFormationTemplate);expect(c).to.have.been.calledWithExactly(["**.zip"],{cwd:path.join(n.serverless.serviceDir,".serverless"),dot:true,silent:true});expect(r).to.have.been.calledWith(path.resolve(n.serverless.serviceDir,".serverless/my-service.zip"));expect(n.serverless.service.provider.shouldNotDeploy).to.equal(undefined)})});it("should not set a flag if remote and local hashes are the same but are duplicated",()=>{c.returns(["func1.zip","func2.zip"]);i.createHash().update().digest.onCall(0).returns("remote-hash-cf-template");i.createHash().update().digest.onCall(1).returns("remote-hash-zip-file-1");i.createHash().update().digest.onCall(2).returns("remote-hash-zip-file-1");const e=[{Metadata:{filesha256:"remote-hash-cf-template"}},{Metadata:{filesha256:"remote-hash-zip-file-1"}}];return expect(n.checkIfDeploymentIsNecessary(e)).to.be.fulfilled.then(()=>{expect(o).to.have.been.calledOnce;expect(c).to.have.been.calledOnce;expect(r).to.have.been.calledTwice;expect(n.serverless.cli.log).to.not.have.been.called;expect(o).to.have.been.calledWithExactly(n.serverless.service.provider.compiledCloudFormationTemplate);expect(c).to.have.been.calledWithExactly(["**.zip"],{cwd:path.join(n.serverless.serviceDir,".serverless"),dot:true,silent:true});expect(r).to.have.been.calledWith(path.resolve(n.serverless.serviceDir,".serverless/func1.zip"));expect(r).to.have.been.calledWith(path.resolve(n.serverless.serviceDir,".serverless/func2.zip"));expect(n.serverless.service.provider.shouldNotDeploy).to.equal(undefined)})});it("should not set a flag if the hashes are equal, but the objects were modified after their functions",()=>{c.returns(["my-service.zip"]);i.createHash().update().digest.onCall(0).returns("hash-cf-template");i.createHash().update().digest.onCall(1).returns("hash-zip-file-1");const e=new Date;const t=new Date((new Date).getTime()-1e5);const s=new Date((new Date).getTime()+1e5);const a=[{Metadata:{filesha256:"hash-cf-template"},LastModified:t},{Metadata:{filesha256:"hash-zip-file-1"},LastModified:s}];return expect(n.checkIfDeploymentIsNecessary(a,e)).to.be.fulfilled.then(()=>{expect(o).to.have.been.calledOnce;expect(c).to.have.been.calledOnce;expect(r).to.have.been.calledOnce;expect(n.serverless.cli.log).to.not.have.been.called;expect(o).to.have.been.calledWithExactly(n.serverless.service.provider.compiledCloudFormationTemplate);expect(c).to.have.been.calledWithExactly(["**.zip"],{cwd:path.join(n.serverless.serviceDir,".serverless"),dot:true,silent:true});expect(r).to.have.been.calledWith(path.resolve(n.serverless.serviceDir,".serverless/my-service.zip"));expect(n.serverless.service.provider.shouldNotDeploy).to.equal(undefined)})});it("should set a flag if the remote and local hashes are equal",()=>{c.returns(["my-service.zip"]);i.createHash().update().digest.onCall(0).returns("hash-cf-template");i.createHash().update().digest.onCall(1).returns("hash-zip-file-1");const e=[{Metadata:{filesha256:"hash-cf-template"}},{Metadata:{filesha256:"hash-zip-file-1"}}];return expect(n.checkIfDeploymentIsNecessary(e)).to.be.fulfilled.then(()=>{expect(o).to.have.been.calledOnce;expect(c).to.have.been.calledOnce;expect(r).to.have.been.calledOnce;expect(n.serverless.cli.log).to.have.been.calledOnce;expect(o).to.have.been.calledWithExactly(n.serverless.service.provider.compiledCloudFormationTemplate);expect(c).to.have.been.calledWithExactly(["**.zip"],{cwd:path.join(n.serverless.serviceDir,".serverless"),dot:true,silent:true});expect(r).to.have.been.calledWith(path.resolve(n.serverless.serviceDir,".serverless/my-service.zip"));expect(n.serverless.service.provider.shouldNotDeploy).to.equal(true)})});it("should set a flag if the remote and local hashes are equal, and the edit times are ordered",()=>{c.returns(["my-service.zip"]);i.createHash().update().digest.onCall(0).returns("hash-cf-template");i.createHash().update().digest.onCall(1).returns("hash-zip-file-1");const e=new Date((new Date).getTime()-1e5);const t=new Date((new Date).getTime()-2e5);const s=[{Metadata:{filesha256:"hash-cf-template"},LastModified:t},{Metadata:{filesha256:"hash-zip-file-1"},LastModified:t}];return expect(n.checkIfDeploymentIsNecessary(s,e)).to.be.fulfilled.then(()=>{expect(o).to.have.been.calledOnce;expect(c).to.have.been.calledOnce;expect(r).to.have.been.calledOnce;expect(n.serverless.cli.log).to.have.been.calledOnce;expect(o).to.have.been.calledWithExactly(n.serverless.service.provider.compiledCloudFormationTemplate);expect(c).to.have.been.calledWithExactly(["**.zip"],{cwd:path.join(n.serverless.serviceDir,".serverless"),dot:true,silent:true});expect(r).to.have.been.calledWith(path.resolve(n.serverless.serviceDir,".serverless/my-service.zip"));expect(n.serverless.service.provider.shouldNotDeploy).to.equal(true)})});it("should set a flag if the remote and local hashes are duplicated and equal",()=>{c.returns(["func1.zip","func2.zip"]);i.createHash().update().digest.onCall(0).returns("hash-cf-template");i.createHash().update().digest.onCall(1).returns("hash-zip-file-1");i.createHash().update().digest.onCall(2).returns("hash-zip-file-1");const e=[{Metadata:{filesha256:"hash-cf-template"}},{Metadata:{filesha256:"hash-zip-file-1"}},{Metadata:{filesha256:"hash-zip-file-1"}}];return expect(n.checkIfDeploymentIsNecessary(e)).to.be.fulfilled.then(()=>{expect(o).to.have.been.calledOnce;expect(c).to.have.been.calledOnce;expect(r).to.have.been.calledTwice;expect(n.serverless.cli.log).to.have.been.calledOnce;expect(o).to.have.been.calledWithExactly(n.serverless.service.provider.compiledCloudFormationTemplate);expect(c).to.have.been.calledWithExactly(["**.zip"],{cwd:path.join(n.serverless.serviceDir,".serverless"),dot:true,silent:true});expect(r).to.have.been.calledWith(path.resolve(n.serverless.serviceDir,".serverless/func1.zip"));expect(r).to.have.been.calledWith(path.resolve(n.serverless.serviceDir,".serverless/func2.zip"));expect(n.serverless.service.provider.shouldNotDeploy).to.equal(true)})});it("should not set a flag if the remote and local hashes are different for package.artifact",()=>{n.serverless.service.package={artifact:"foo/bar/my-own.zip"};c.returns([]);i.createHash().update().digest.onCall(0).returns("hash-cf-template");i.createHash().update().digest.onCall(1).returns("local-my-own-hash");const e=[{Metadata:{filesha256:"hash-cf-template"}},{Metadata:{filesha256:"remote-my-own-hash"}}];return expect(n.checkIfDeploymentIsNecessary(e)).to.be.fulfilled.then(()=>{expect(o).to.have.been.calledOnce;expect(c).to.have.been.calledOnce;expect(r).to.have.been.calledOnce;expect(n.serverless.cli.log).not.to.be.called;expect(o).to.have.been.calledWithExactly(n.serverless.service.provider.compiledCloudFormationTemplate);expect(c).to.have.been.calledWithExactly(["**.zip"],{cwd:path.join(n.serverless.serviceDir,".serverless"),dot:true,silent:true});expect(r).to.have.been.calledWith(path.resolve(n.serverless.serviceDir,"foo/bar/my-own.zip"));expect(n.serverless.service.provider.shouldNotDeploy).to.equal(undefined)})})})});describe("checkForChanges #2",()=>{it("Should recognize package.artifact",()=>runServerless({fixture:"packageArtifact",command:"deploy",env:{AWS_CONTAINER_CREDENTIALS_FULL_URI:"ignore"},lastLifecycleHookName:"aws:deploy:deploy:checkForChanges",awsRequestStubMap:{CloudFormation:{describeStacks:{},describeStackResource:{StackResourceDetail:{PhysicalResourceId:"deployment-bucket"}}},Lambda:{getFunction:{Configuration:{LastModified:"2020-05-20T15:34:16.494+0000"}}},S3:{headObject:{Metadata:{filesha256:"RRYyTm4Ri8mocpvx44pvas4JKLYtdJS3Z8MOlrZrDXA="}},listObjectsV2:{Contents:[{Key:"serverless/test-package-artifact/dev/1589988704359-2020-05-20T15:31:44.359Z/artifact.zip",LastModified:new Date,ETag:'"5102a4cf710cae6497dba9e61b85d0a4"',Size:356,StorageClass:"STANDARD"}]}},STS:{getCallerIdentity:{ResponseMetadata:{RequestId:"ffffffff-ffff-ffff-ffff-ffffffffffff"},UserId:"XXXXXXXXXXXXXXXXXXXXX",Account:"999999999999",Arn:"arn:aws:iam::999999999999:user/test"}}}}).then(({cfTemplate:e})=>{expect(e.Resources.FooLambdaFunction.Properties.Code.S3Key.endsWith("/artifact.zip")).to.be.true}))});const commonAwsSdkMock={CloudFormation:{describeStacks:{},describeStackResource:{StackResourceDetail:{PhysicalResourceId:"deployment-bucket"}}},STS:{getCallerIdentity:{ResponseMetadata:{RequestId:"ffffffff-ffff-ffff-ffff-ffffffffffff"},UserId:"XXXXXXXXXXXXXXXXXXXXX",Account:"999999999999",Arn:"arn:aws:iam::999999999999:user/test"}}};const generateMatchingListObjectsResponse=async e=>{const t=`${e.serviceDir}/.serverless`;const s=await globby(t,{expandDirectories:{extensions:["zip"]}});s.push("compiled-cloudformation-template.json");return{Contents:s.map(e=>({Key:`serverless/test-package-artifact/dev/1589988704359-2020-05-20T15:31:44.359Z/${e}`,LastModified:new Date("2020-05-20T15:30:16.494+0000")}))}};const generateMatchingHeadObjectResponse=async(o,{Key:e})=>{if(path.basename(e)==="compiled-cloudformation-template.json"){const s=o.service.provider.compiledCloudFormationTemplate;const a=normalizeFiles.normalizeCloudFormationTemplate(s);const t=crypto.createHash("sha256").update(JSON.stringify(a)).digest("base64");return{Metadata:{filesha256:t}}}const t=await(async a=>{return new Promise(e=>{const t=crypto.createHash("sha256");const s=fs.createReadStream(`${o.serviceDir}/.serverless/${a}`);s.on("data",e=>t.update(e));s.on("close",()=>e(t.digest("base64")))})})(e);return{Metadata:{filesha256:t}}};describe("test/unit/lib/plugins/aws/deploy/lib/checkForChanges.test.js",()=>{it.skip("TODO: should not deploy if artifacts in bucket are same as locally and modification dates for all functions are later than uploaded artifacts dates",async()=>{let t;await runServerless({fixture:"checkForChanges",command:"deploy",lastLifecycleHookName:"aws:deploy:deploy:checkForChanges",env:{AWS_CONTAINER_CREDENTIALS_FULL_URI:"ignore"},hooks:{beforeInstanceInit:e=>t=e},awsRequestStubMap:{...commonAwsSdkMock,Lambda:{getFunction:{Configuration:{LastModified:"2021-05-20T15:34:16.494+0000"}}},S3:{listObjectsV2:async()=>generateMatchingListObjectsResponse(t),headObject:async e=>generateMatchingHeadObjectResponse(t,e)}}});expect(t.service.provider.shouldNotDeploy).to.equal(true)});it.skip("TODO: should deploy with --force option",async()=>{let t;await runServerless({fixture:"checkForChanges",command:"deploy",options:{force:true},lastLifecycleHookName:"aws:deploy:deploy:checkForChanges",env:{AWS_CONTAINER_CREDENTIALS_FULL_URI:"ignore"},hooks:{beforeInstanceInit:e=>t=e},awsRequestStubMap:{...commonAwsSdkMock,Lambda:{getFunction:{Configuration:{LastModified:"2021-05-20T15:34:16.494+0000"}}},S3:{listObjectsV2:async()=>generateMatchingListObjectsResponse(t),headObject:async e=>generateMatchingHeadObjectResponse(t,e)}}});expect(t.service.provider.shouldNotDeploy).to.equal(false)});it.skip("TODO: should deploy when deployment bucket is empty (first deployment)",async()=>{const{serverless:e}=await runServerless({fixture:"packageFoldern",command:"deploy",lastLifecycleHookName:"aws:deploy:deploy:checkForChanges",env:{AWS_CONTAINER_CREDENTIALS_FULL_URI:"ignore"},awsRequestStubMap:{...commonAwsSdkMock,Lambda:{getFunction:async()=>{}},S3:{listObjectsV2:async()=>{}}}});expect(e.service.provider.shouldNotDeploy).to.equal(false)});it.skip("TODO: should compare against latest deployment artifacts",async()=>{let t;await runServerless({fixture:"checkForChanges",command:"deploy",lastLifecycleHookName:"aws:deploy:deploy:checkForChanges",env:{AWS_CONTAINER_CREDENTIALS_FULL_URI:"ignore"},hooks:{beforeInstanceInit:e=>t=e},awsRequestStubMap:{...commonAwsSdkMock,Lambda:{getFunction:{Configuration:{LastModified:"2021-05-20T15:34:16.494+0000"}}},S3:{listObjectsV2:async()=>generateMatchingListObjectsResponse(t),headObject:async e=>generateMatchingHeadObjectResponse(t,e)}}});expect(t.service.provider.shouldNotDeploy).to.equal(true)});it.skip("TODO: should deploy if new function was introduced and otherwise there were no other changes",async()=>{let t;await runServerless({fixture:"checkForChanges",command:"deploy",lastLifecycleHookName:"aws:deploy:deploy:checkForChanges",env:{AWS_CONTAINER_CREDENTIALS_FULL_URI:"ignore"},hooks:{beforeInstanceInit:e=>t=e},awsRequestStubMap:{...commonAwsSdkMock,Lambda:{getFunction:()=>{}},S3:{listObjectsV2:async()=>generateMatchingListObjectsResponse(t),headObject:async e=>generateMatchingHeadObjectResponse(t,e)}}});expect(t.service.provider.shouldNotDeploy).to.equal(false)});it.skip("TODO: should deploy if individually packaged function was removed",async()=>{const{fixtureData:{updateConfig:e,servicePath:t}}=await runServerless({fixture:"checkForChanges",command:"package"});const s=await generateMatchingListObjectsResponse(a);await e({functions:{fnIndividually:null}});let a;await runServerless({cwd:t,command:"package",lastLifecycleHookName:"aws:deploy:deploy:checkForChanges",env:{AWS_CONTAINER_CREDENTIALS_FULL_URI:"ignore"},hooks:{beforeInstanceInit:e=>a=e},awsRequestStubMap:{...commonAwsSdkMock,Lambda:{getFunction:{Configuration:{LastModified:"2021-05-20T15:34:16.494+0000"}}},S3:{listObjectsV2:()=>s,headObject:async e=>generateMatchingHeadObjectResponse(a,e)}}});expect(a.service.provider.shouldNotDeploy).to.equal(false)});it.skip("TODO: should deploy if remote hashes are different",async()=>{let t;await runServerless({fixture:"checkForChanges",command:"deploy",lastLifecycleHookName:"aws:deploy:deploy:checkForChanges",env:{AWS_CONTAINER_CREDENTIALS_FULL_URI:"ignore"},hooks:{beforeInstanceInit:e=>t=e},awsRequestStubMap:{...commonAwsSdkMock,Lambda:{getFunction:{Configuration:{LastModified:"2021-05-20T15:34:16.494+0000"}}},S3:{listObjectsV2:async()=>generateMatchingListObjectsResponse(t),headObject:async e=>generateMatchingHeadObjectResponse(t,e)}}});expect(t.service.provider.shouldNotDeploy).to.equal(false)});it.skip("TODO: should deploy if count of hashes (not their content) differs",async()=>{let t;await runServerless({fixture:"checkForChanges",command:"deploy",configExt:{package:{individually:true}},lastLifecycleHookName:"aws:deploy:deploy:checkForChanges",env:{AWS_CONTAINER_CREDENTIALS_FULL_URI:"ignore"},hooks:{beforeInstanceInit:e=>t=e},awsRequestStubMap:{...commonAwsSdkMock,Lambda:{getFunction:{Configuration:{LastModified:"2021-05-20T15:34:16.494+0000"}}},S3:{listObjectsV2:async()=>generateMatchingListObjectsResponse(t),headObject:async e=>generateMatchingHeadObjectResponse(t,e)}}});expect(t.service.provider.shouldNotDeploy).to.equal(false)});it.skip("TODO: should deploy if uploaded artifacts are newer than function configuration modification date",async()=>{let t;await runServerless({fixture:"checkForChanges",command:"deploy",configExt:{package:{individually:true}},lastLifecycleHookName:"aws:deploy:deploy:checkForChanges",env:{AWS_CONTAINER_CREDENTIALS_FULL_URI:"ignore"},hooks:{beforeInstanceInit:e=>t=e},awsRequestStubMap:{...commonAwsSdkMock,Lambda:{getFunction:()=>{}},S3:{listObjectsV2:async()=>generateMatchingListObjectsResponse(t),headObject:async e=>generateMatchingHeadObjectResponse(t,e)}}});expect(t.service.provider.shouldNotDeploy).to.equal(false)});it.skip("TODO: should deploy if custom package.artifact have changed",async()=>{let t;await runServerless({fixture:"checkForChanges",command:"deploy",configExt:{package:{artifact:"artifact.zip"}},lastLifecycleHookName:"aws:deploy:deploy:checkForChanges",env:{AWS_CONTAINER_CREDENTIALS_FULL_URI:"ignore"},hooks:{beforeInstanceInit:e=>t=e},awsRequestStubMap:{...commonAwsSdkMock,Lambda:{getFunction:{Configuration:{LastModified:"2021-05-20T15:34:16.494+0000"}}},S3:{listObjectsV2:async()=>generateMatchingListObjectsResponse(t),headObject:async e=>generateMatchingHeadObjectResponse(t,e)}}});expect(t.service.provider.shouldNotDeploy).to.equal(false)});it("should skip a deployment with identical hashes and package.artifact targeting .serverless directory",async()=>{const{serverless:e}=await runServerless({fixture:"packageArtifactInServerlessDir",command:"deploy",configExt:{service:"test-packageArtifactInServerlessDir"},env:{AWS_CONTAINER_CREDENTIALS_FULL_URI:"ignore"},lastLifecycleHookName:"aws:deploy:deploy:checkForChanges",awsRequestStubMap:{...commonAwsSdkMock,Lambda:{getFunction:{Configuration:{LastModified:"2020-05-20T15:34:16.494+0000"}}},S3:{headObject:(()=>{const e=sandbox.stub();e.withArgs({Bucket:"deployment-bucket",Key:"serverless/test-package-artifact/dev/1589988704359-2020-05-20T15:31:44.359Z/compiled-cloudformation-template.json"}).returns({Metadata:{filesha256:"pZOdrt6qijT7ITsLQjPP9QwgMAfKA2RuUUSTW+l8wWs="}});e.withArgs({Bucket:"deployment-bucket",Key:"serverless/test-package-artifact/dev/1589988704359-2020-05-20T15:31:44.359Z/my-own.zip"}).returns({Metadata:{filesha256:"T0qEYHOE4Xv2E8Ar03xGogAlElcdf/dQh/lh9ao7Glo="}});return e})(),listObjectsV2:{Contents:[{Key:"serverless/test-package-artifact/dev/1589988704359-2020-05-20T15:31:44.359Z/compiled-cloudformation-template.json",LastModified:new Date,ETag:'"5102a4cf710cae6497dba9e61b85d0a4"',Size:356,StorageClass:"STANDARD"},{Key:"serverless/test-package-artifact/dev/1589988704359-2020-05-20T15:31:44.359Z/my-own.zip",LastModified:new Date,ETag:'"5102a4cf710cae6497dba9e61b85d0a4"',Size:356,StorageClass:"STANDARD"}]}}}});expect(e.service.provider.shouldNotDeploy).to.equal(true)});it("should print a warning if missing lambda:GetFunction permission",async()=>{const{stdoutData:e}=await runServerless({fixture:"checkForChanges",command:"deploy",lastLifecycleHookName:"aws:deploy:deploy:checkForChanges",awsRequestStubMap:{...commonAwsSdkMock,Lambda:{getFunction:sandbox.stub().throws({providerError:{statusCode:403}})},S3:{listObjectsV2:{}}}});expect(e).to.include(["WARNING: Not authorized to perform: lambda:GetFunction for at least one of the lambda functions."," Deployment will not be skipped even if service files did not change. "].join(""))});it.skip("TODO: should crash meaningfully if bucket does not exist",()=>{return expect(runServerless({fixture:"checkForChanges",command:"deploy",lastLifecycleHookName:"aws:deploy:deploy:checkForChanges",env:{AWS_CONTAINER_CREDENTIALS_FULL_URI:"ignore"},awsRequestStubMap:{...commonAwsSdkMock,S3:{listObjectsV2:async()=>{}}}})).to.eventually.be.rejected.and.have.property("code")});it.skip("TODO: should handle gently other AWS SDK errors",()=>{return expect(runServerless({fixture:"checkForChanges",command:"deploy",lastLifecycleHookName:"aws:deploy:deploy:checkForChanges",env:{AWS_CONTAINER_CREDENTIALS_FULL_URI:"ignore"},awsRequestStubMap:{...commonAwsSdkMock,S3:{listObjectsV2:async()=>{}}}})).to.eventually.be.rejected.and.have.property("code")});describe("checkLogGroupSubscriptionFilterResourceLimitExceeded",()=>{it("should not attempt to delete and add filter for same destination",async()=>{const e=sandbox.stub();let s;await runServerless({fixture:"checkForChanges",command:"deploy",configExt:{functions:{fn1:{events:[{cloudwatchLog:"someLogGroupName"}]}}},lastLifecycleHookName:"aws:deploy:deploy:checkForChanges",env:{AWS_CONTAINER_CREDENTIALS_FULL_URI:"ignore"},hooks:{beforeInstanceInit:e=>s=e},awsRequestStubMap:{...commonAwsSdkMock,Lambda:{getFunction:{Configuration:{LastModified:"2021-05-20T15:34:16.494+0000"}}},S3:{listObjectsV2:async()=>generateMatchingListObjectsResponse(s),headObject:async e=>generateMatchingHeadObjectResponse(s,e)},CloudWatchLogs:{deleteSubscriptionFilter:e,describeSubscriptionFilters:async()=>{const e=s.service.getFunction("fn1").name;const t=s.getProvider("aws").naming;return{subscriptionFilters:[{filterName:`${t.getStackName()}-${t.getCloudWatchLogLogicalId("Fn1",1)}-xxxxx`,destinationArn:`arn:aws:lambda:us-east-1:999999999999:function:${e}`},{filterName:`${t.getStackName()}-${t.getCloudWatchLogLogicalId("Fn2",1)}-xxxxx`,destinationArn:"arn:aws:lambda:us-east-1:999999999999:function:test-checkForChanges-cdr3ogg-dev-fn1"}]}}}}});expect(e).to.not.have.been.called});it("should not attempt to delete filter by 2 subscription filter per log group",async()=>{const e=sandbox.stub();let t;await runServerless({fixture:"checkForChanges",command:"deploy",configExt:{functions:{fn1:{events:[{cloudwatchLog:"someLogGroupName"}]}}},lastLifecycleHookName:"aws:deploy:deploy:checkForChanges",env:{AWS_CONTAINER_CREDENTIALS_FULL_URI:"ignore"},hooks:{beforeInstanceInit:e=>t=e},awsRequestStubMap:{...commonAwsSdkMock,Lambda:{getFunction:{Configuration:{LastModified:"2021-05-20T15:34:16.494+0000"}}},S3:{listObjectsV2:async()=>generateMatchingListObjectsResponse(t),headObject:async e=>generateMatchingHeadObjectResponse(t,e)},CloudWatchLogs:{deleteSubscriptionFilter:e,describeSubscriptionFilters:async()=>{const e=t.getProvider("aws").naming;return{subscriptionFilters:[{filterName:`${e.getStackName()}-${e.getCloudWatchLogLogicalId("Fn1",1)}-xxxxx`,destinationArn:"arn:aws:lambda:us-east-1:999999999999:function:test-checkForChanges-cdr3ogg-dev-fn1"}]}}}}});expect(e).to.not.have.been.called});it("should attempt to delete filter over 2 subscription filter per log group",async()=>{const e=sandbox.stub();let t;const{awsNaming:s}=await runServerless({fixture:"checkForChanges",command:"deploy",configExt:{functions:{fn1:{events:[{cloudwatchLog:"someLogGroupName"}]}}},lastLifecycleHookName:"aws:deploy:deploy:checkForChanges",env:{AWS_CONTAINER_CREDENTIALS_FULL_URI:"ignore"},hooks:{beforeInstanceInit:e=>t=e},awsRequestStubMap:{...commonAwsSdkMock,Lambda:{getFunction:{Configuration:{LastModified:"2021-05-20T15:34:16.494+0000"}}},S3:{listObjectsV2:async()=>generateMatchingListObjectsResponse(t),headObject:async e=>generateMatchingHeadObjectResponse(t,e)},CloudWatchLogs:{deleteSubscriptionFilter:e,describeSubscriptionFilters:async()=>{const e=t.getProvider("aws").naming;return{subscriptionFilters:[{filterName:`${e.getStackName()}-${e.getCloudWatchLogLogicalId("Fn2",1)}-xxxxx`,destinationArn:"arn:aws:lambda:us-east-1:999999999999:function:test-checkForChanges-cdr3ogg-dev-fn1"},{filterName:`${e.getStackName()}-${e.getCloudWatchLogLogicalId("Fn2",2)}-xxxxx`,destinationArn:`arn:aws:lambda:us-east-1:999999999999:function:${t.service.getFunction("fn1").name}`}]}}}}});expect(e).to.have.been.calledOnceWith({logGroupName:"someLogGroupName",filterName:`${s.getStackName()}-${s.getCloudWatchLogLogicalId("Fn2",2)}-xxxxx`})});it("should attempt to delete filter if order of cloudwatch events changed",async()=>{const e=sandbox.stub();let t;const{awsNaming:s}=await runServerless({fixture:"checkForChanges",command:"deploy",configExt:{functions:{fn1:{events:[{cloudwatchLog:"someLogGroupName1"},{cloudwatchLog:"someLogGroupName2"}]}}},lastLifecycleHookName:"aws:deploy:deploy:checkForChanges",env:{AWS_CONTAINER_CREDENTIALS_FULL_URI:"ignore"},hooks:{beforeInstanceInit:e=>t=e},awsRequestStubMap:{...commonAwsSdkMock,Lambda:{getFunction:{Configuration:{LastModified:"2021-05-20T15:34:16.494+0000"}}},S3:{listObjectsV2:async()=>generateMatchingListObjectsResponse(t),headObject:async e=>generateMatchingHeadObjectResponse(t,e)},CloudWatchLogs:{deleteSubscriptionFilter:e,describeSubscriptionFilters:sandbox.stub().onFirstCall().callsFake(async()=>{const e=t.getProvider("aws").naming;return{subscriptionFilters:[{filterName:`${e.getStackName()}-${e.getCloudWatchLogLogicalId("Fn1",1)}-xxxxx`,destinationArn:`arn:aws:lambda:us-east-1:999999999999:function:${t.service.getFunction("fn1").name}`}]}}).onSecondCall().callsFake(async()=>{const e=t.getProvider("aws").naming;return{subscriptionFilters:[{filterName:`${e.getStackName()}-${e.getCloudWatchLogLogicalId("Fn1",1)}-xxxxx`,destinationArn:`arn:aws:lambda:us-east-1:999999999999:function:${t.service.getFunction("fn1").name}`}]}})}}});expect(e).to.have.been.calledOnceWith({logGroupName:"someLogGroupName2",filterName:`${s.getStackName()}-${s.getCloudWatchLogLogicalId("Fn1",1)}-xxxxx`})});it("should attempt to delete multiple filters",async()=>{const e=sandbox.stub();let t;const{awsNaming:s}=await runServerless({fixture:"checkForChanges",command:"deploy",configExt:{functions:{fn1:{events:[{cloudwatchLog:"someLogGroupName"},{cloudwatchLog:"someLogGroupName"}]}}},lastLifecycleHookName:"aws:deploy:deploy:checkForChanges",env:{AWS_CONTAINER_CREDENTIALS_FULL_URI:"ignore"},hooks:{beforeInstanceInit:e=>t=e},awsRequestStubMap:{...commonAwsSdkMock,Lambda:{getFunction:{Configuration:{LastModified:"2021-05-20T15:34:16.494+0000"}}},S3:{listObjectsV2:async()=>generateMatchingListObjectsResponse(t),headObject:async e=>generateMatchingHeadObjectResponse(t,e)},CloudWatchLogs:{deleteSubscriptionFilter:e,describeSubscriptionFilters:sandbox.stub().onFirstCall().callsFake(async()=>{const e=t.getProvider("aws").naming;return{subscriptionFilters:[{filterName:`${e.getStackName()}-${e.getCloudWatchLogLogicalId("Fn1",1)}-xxxxx`,destinationArn:"arn:aws:lambda:us-east-1:999999999999:function:test-checkForChanges-cdr3ogg-dev-fn1"},{filterName:`${e.getStackName()}-${e.getCloudWatchLogLogicalId("Fn1",2)}-xxxxx`,destinationArn:"arn:aws:lambda:us-east-1:999999999999:function:test-checkForChanges-cdr3ogg-dev-fn1"}]}})}}});expect(e).to.have.been.calledTwice;expect(e).to.have.been.calledWith({logGroupName:"someLogGroupName",filterName:`${s.getStackName()}-${s.getCloudWatchLogLogicalId("Fn1",1)}-xxxxx`});expect(e).to.have.been.calledWith({logGroupName:"someLogGroupName",filterName:`${s.getStackName()}-${s.getCloudWatchLogLogicalId("Fn1",2)}-xxxxx`})});it("should recognize custom partition",async()=>{const e=sandbox.stub();let t;await runServerless({fixture:"checkForChanges",command:"deploy",configExt:{functions:{fn1:{events:[{cloudwatchLog:"someLogGroupName"}]}}},lastLifecycleHookName:"aws:deploy:deploy:checkForChanges",env:{AWS_CONTAINER_CREDENTIALS_FULL_URI:"ignore"},hooks:{beforeInstanceInit:e=>t=e},awsRequestStubMap:{...commonAwsSdkMock,STS:{getCallerIdentity:{ResponseMetadata:{RequestId:"ffffffff-ffff-ffff-ffff-ffffffffffff"},UserId:"XXXXXXXXXXXXXXXXXXXXX",Account:"999999999999",Arn:"arn:aws-us-gov:iam::999999999999:user/test"}},Lambda:{getFunction:{Configuration:{LastModified:"2021-05-20T15:34:16.494+0000"}}},S3:{listObjectsV2:async()=>generateMatchingListObjectsResponse(t),headObject:async e=>generateMatchingHeadObjectResponse(t,e)},CloudWatchLogs:{describeSubscriptionFilters:sandbox.stub().callsFake(async()=>{const e=t.getProvider("aws").naming;return{subscriptionFilters:[{filterName:`${e.getStackName()}-${e.getCloudWatchLogLogicalId("Fn1",1)}-xxxxx`,destinationArn:`arn:aws-us-gov:lambda:us-east-1:999999999999:function:${t.service.getFunction("fn1").name}`}]}}),deleteSubscriptionFilter:e}}});expect(e).to.not.have.been.called})})});