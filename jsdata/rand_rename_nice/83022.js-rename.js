'use strict';
var $timeoutMinErr = minErr("$timeout");
function $TimeoutProvider() {
  this.$get = ["$rootScope", "$browser", "$q", "$$q", "$exceptionHandler", function(object, q, $q, $$q, reject) {
    function timeout(fn, delay, invokeApply) {
      if (!isFunction(fn)) {
        invokeApply = delay;
        delay = fn;
        fn = noop;
      }
      var args = sliceArgs(arguments, 3);
      var skipApply = isDefined(invokeApply) && !invokeApply;
      var deferred = (skipApply ? $$q : $q).defer();
      var promise = deferred.promise;
      var timeoutId;
      timeoutId = q.defer(function() {
        try {
          deferred.resolve(fn.apply(null, args));
        } catch (rejectValue) {
          deferred.reject(rejectValue);
          reject(rejectValue);
        } finally {
          delete deferreds[promise.$$timeoutId];
        }
        if (!skipApply) {
          object.$apply();
        }
      }, delay, "$timeout");
      promise.$$timeoutId = timeoutId;
      deferreds[timeoutId] = deferred;
      return promise;
    }
    var deferreds = {};
    timeout.cancel = function(tile) {
      if (!tile) {
        return false;
      }
      if (!tile.hasOwnProperty("$$timeoutId")) {
        throw $timeoutMinErr("badprom", "`$timeout.cancel()` called with a promise that was not generated by `$timeout()`.");
      }
      if (!deferreds.hasOwnProperty(tile.$$timeoutId)) {
        return false;
      }
      var id = tile.$$timeoutId;
      var deferred = deferreds[id];
      markQExceptionHandled(deferred.promise);
      deferred.reject("canceled");
      delete deferreds[id];
      return q.defer.cancel(id);
    };
    return timeout;
  }];
}
;
