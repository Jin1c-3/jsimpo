"use strict";const MESSAGE_ID_UNIQUE="unique";const MESSAGE_ID_CONFLICTING="conflicting";const conflictingFlags=[["Leading","Trailing","Dangling"],["Block","Line"]];const isCommentCheckFlags=e=>e.type==="MemberExpression"&&!e.computed&&!e.optional&&e.object.type==="Identifier"&&e.object.name==="CommentCheckFlags"&&e.property.type==="Identifier";const flatFlags=e=>{const t=[];const n=[e];while(n.length>0){const{left:o,right:s}=n.shift();for(const e of[o,s]){if(e.type==="BinaryExpression"&&e.operator==="|"){n.push(e);continue}if(!isCommentCheckFlags(e)){return[]}t.push(e)}}return t.map(e=>e.property.name)};module.exports={meta:{type:"suggestion",docs:{url:"https://github.com/prettier/prettier/blob/main/scripts/tools/eslint-plugin-prettier-internal-rules/no-conflicting-comment-check-flags.js"},messages:{[MESSAGE_ID_UNIQUE]:"Do not use same flag multiple times.",[MESSAGE_ID_CONFLICTING]:"Do not use {{flags}} together."}},create(i){return{':not(BinaryExpression) > BinaryExpression[operator="|"]'(e){const t=flatFlags(e);if(t.length<2){return}const n=new Set(t);if(n.size!==t.length){i.report({node:e,messageId:MESSAGE_ID_UNIQUE});return}for(const o of conflictingFlags){const s=o.filter(e=>n.has(e));if(s.length>1){i.report({node:e,messageId:MESSAGE_ID_CONFLICTING,data:{flags:s.map(e=>`'CommentCheckFlags.${e}'`).join(", ")}})}}}}}};