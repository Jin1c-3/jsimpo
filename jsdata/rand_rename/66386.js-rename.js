"use strict";const npa=require("npm-package-arg");const semver=require("semver");const{checkEngine}=require("npm-install-checks");const normalizeBin=require("npm-normalize-package-bin");const engineOk=(e,s,o)=>{try{checkEngine(e,s,o);return true}catch(e){return false}};const isBefore=(e,s,o)=>!e||!e[s]||Date.parse(e[s])<=o;const avoidSemverOpt={includePrerelease:true,loose:true};const shouldAvoid=(e,s)=>s&&semver.satisfies(e,s,avoidSemverOpt);const decorateAvoid=(e,s)=>e&&shouldAvoid(e.version,s)?{...e,_shouldAvoid:true}:e;const pickManifest=(e,s,o)=>{const{defaultTag:n="latest",before:t=null,nodeVersion:m=process.version,npmVersion:h=null,includeStaged:r=false,avoid:b=null,avoidStrict:i=false}=o;const{name:c,time:a}=e;const d=e.versions||{};if(i){const E={...o,avoidStrict:false};const j=pickManifest(e,s,E);if(!j||!j._shouldAvoid){return j}const S=pickManifest(e,`^${j.version}`,E);if(!S||!S._shouldAvoid){return{...S,_outsideDependencyRange:true,_isSemVerMajor:false}}const $=pickManifest(e,"*",E);if(!$||!$._shouldAvoid){return{...$,_outsideDependencyRange:true,_isSemVerMajor:true}}throw Object.assign(new Error(`No avoidable versions for ${c}`),{code:"ETARGET",name:c,wanted:s,avoid:b,before:t,versions:Object.keys(d)})}const k=r&&e.stagedVersions&&e.stagedVersions.versions||{};const O=e.policyRestrictions&&e.policyRestrictions.versions||{};const l=t&&a?+new Date(t):Infinity;const u=npa.resolve(c,s||n);const v=u.type;const f=e["dist-tags"]||{};if(v!=="tag"&&v!=="version"&&v!=="range"){throw new Error("Only tag, version, and range are supported")}if(s&&v==="tag"){const M=f[s];if(isBefore(a,M,l)){return decorateAvoid(d[M]||k[M]||O[M],b)}else{return pickManifest(e,`<=${M}`,o)}}if(s&&v==="version"){const M=semver.clean(s,{loose:true});const R=d[M]||k[M]||O[M];return isBefore(a,M,l)?decorateAvoid(R,b):null}const p=v==="range"?s:"*";const g=f[n];if(g&&(p==="*"||semver.satisfies(g,p,{loose:true}))&&!shouldAvoid(g,b)){const R=d[g];if(R&&isBefore(a,g,l)){return R}}const y=Object.entries(d).concat(Object.entries(k)).concat(Object.entries(O)).filter(([e,s])=>isBefore(a,e,l));if(!y.length){throw Object.assign(new Error(`No versions available for ${c}`),{code:"ENOVERSIONS",name:c,type:v,wanted:s,before:t,versions:Object.keys(d)})}const w={loose:true};const A=y.filter(([e,s])=>semver.satisfies(e,p,{loose:true})).sort((e,s)=>{const[o,n]=e;const[t,r]=s;const i=!shouldAvoid(o,b);const c=!shouldAvoid(t,b);const a=!O[e];const d=!O[s];const l=!k[e];const u=!k[s];const v=!n.deprecated;const f=!r.deprecated;const p=engineOk(n,h,m);const g=engineOk(r,h,m);return c-i||d-a||u-l||(f&&g)-(v&&p)||g-p||f-v||semver.rcompare(o,t,w)});return decorateAvoid(A[0]&&A[0][1],b)};module.exports=(e,s,o={})=>{const n=pickManifest(e,s,o);const t=n&&normalizeBin(n);const r=e.policyRestrictions;const i=r&&r.versions||{};if(t&&!i[t.version]){return t}const{before:c=null,defaultTag:a="latest"}=o;const d=c?new Date(c).toLocaleString():"";const{name:l}=e;const u=`${l}@${s}`+(c?` with a date before ${d}`:"");const v=t&&!!i[t.version];const f=v?r.message:"";const p=!v?`No matching version found for ${u}.`:`Could not download ${u} due to policy violations:\n${f}`;const g=v?"E403":"ETARGET";throw Object.assign(new Error(p),{code:g,type:npa.resolve(e.name,s).type,wanted:s,versions:Object.keys(e.versions),name:l,distTags:e["dist-tags"],defaultTag:a})};