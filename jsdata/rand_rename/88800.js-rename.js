const fs=Plugin.fs;const path=Plugin.path;const createHash=Npm.require("crypto").createHash;const assert=Npm.require("assert");const LRU=Npm.require("lru-cache");CachingCompilerBase=class e{constructor({compilerName:e,defaultCacheSize:t,maxParallelism:s=20}){this._compilerName=e;this._maxParallelism=s;const i=e.toUpperCase().replace("/-/g","_").replace(/[^A-Z0-9_]/g,"");const r="METEOR_"+i+"_CACHE_";const a=r+"DEBUG";this._cacheDebugEnabled=!!process.env[a];const c=r+"SIZE";this._cacheSize=+process.env[c]||t;this._diskCache=null;this._callCount=0;this._afterLinkCallbacks=[]}getCacheKey(e){throw Error("CachingCompiler subclass should implement getCacheKey!")}addCompileResult(e,t){throw Error("CachingCompiler subclass should implement addCompileResult!")}compileResultSize(e){throw Error("CachingCompiler subclass should implement compileResultSize!")}stringifyCompileResult(e){return JSON.stringify(e)}parseCompileResult(e){return this._parseJSONOrNull(e)}_parseJSONOrNull(e){try{return JSON.parse(e)}catch(e){if(e instanceof SyntaxError)return null;throw e}}_cacheDebug(e){if(!this._cacheDebugEnabled)return;console.log(`CACHE(${this._compilerName}): ${e}`)}setDiskCacheDirectory(e){if(this._diskCache)throw Error("setDiskCacheDirectory called twice?");this._diskCache=e}sourceMapSize(e){if(!e)return 0;return e.mappings.length+(e.sourcesContent||[]).reduce(function(e,t){return e+(t?t.length:0)},0)}afterLink(){this._afterLinkCallbacks.splice(0).forEach(e=>{e()})}_deepHash(t){const s=createHash("sha1");let e=typeof t;if(t===null){e="null"}s.update(e+"\0");switch(e){case"object":const i=Object.keys(t);if(!Array.isArray(t)){i.sort()}i.forEach(e=>{if(typeof t[e]==="function"){return}s.update(e+"\0").update(this._deepHash(t[e]))});break;case"function":assert.ok(false,"cannot hash function objects");break;default:s.update(""+t);break}return s.digest("hex")}_writeFile(e,t){const s=e+".tmp."+Random.id();try{fs.writeFileSync(s,t);fs.renameSync(s,e)}catch(e){this._cacheDebug(e)}}_readFileOrNull(e){try{return fs.readFileSync(e,"utf8")}catch(e){if(e&&e.code==="ENOENT")return null;throw e}}};CachingCompiler=class e extends CachingCompilerBase{constructor({compilerName:e,defaultCacheSize:t,maxParallelism:s=20}){super({compilerName:e,defaultCacheSize:t,maxParallelism:s});this._cache=new LRU({max:this._cacheSize,length:e=>this.compileResultSize(e)})}compileOneFile(e){throw Error("CachingCompiler subclass should implement compileOneFile!")}async processFilesForTarget(e){const i=[];const r=this._cacheDebugEnabled&&Object.create(null);e.forEach(s=>{if(r){r[s.getArch()]=1}const e=()=>{const e=this._deepHash(this.getCacheKey(s));let t=this._cache.get(e);if(!t){t=this._readCache(e);if(t){this._cacheDebug(`Loaded ${s.getDisplayPath()}`)}}if(!t){i.push(s.getDisplayPath());t=Promise.await(this.compileOneFile(s));if(!t){return}this._cache.set(e,t);this._writeCacheAsync(e,t)}return t};if(this.compileOneFileLater&&s.supportsLazyCompilation){this.compileOneFileLater(s,e)}else{const t=e();if(t){this.addCompileResult(s,t)}}});if(this._cacheDebugEnabled){this._afterLinkCallbacks.push(()=>{i.sort();this._cacheDebug(`Ran (#${++this._callCount}) on: ${JSON.stringify(i)} ${JSON.stringify(Object.keys(r).sort())}`)})}}_cacheFilename(e){if(!/^[a-f0-9]+$/.test(e)){throw Error("bad cacheKey: "+e)}return path.join(this._diskCache,e+".cache")}_readCache(e){if(!this._diskCache){return null}const t=this._cacheFilename(e);const s=this._readAndParseCompileResultOrNull(t);if(!s){return null}this._cache.set(e,s);return s}_writeCacheAsync(e,t){if(!this._diskCache)return;const s=this._cacheFilename(e);const i=this.stringifyCompileResult(t);this._writeFile(s,i)}_readAndParseCompileResultOrNull(e){const t=this._readFileOrNull(e);return this.parseCompileResult(t)}};