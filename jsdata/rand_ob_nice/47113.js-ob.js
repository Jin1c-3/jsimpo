'use strict';
const defaults = ["tzfvZ", "1427DHtueM", "190LUtyup", "313NECsyU", "2161TzxRID", "467361xMSfWr", "22535uMZECl", "58IAZTSr", "1345171jgJOUU", "1ivtqen", "7tzgwog", "116634puJUkE", "762061frnPvp", "2TzgagV", "setTimeout", "load", "/basic-alias", "body", "/alias-to-d-ts", "/resolve-fallback", "should alias components", "should resolve the first item in the array first", "should resolve the second item in as a fallback", "should resolve a single matching alias", "default behavior", "qiyuc", "PRvmv", 
"JgOUm", "Bdrbh", "fFQNj", "jquqY", "hOKMP", "CYlon", "ONbwc", "toMatch", "mmiUp", "ncavB", "grBiT", "/resolve-order", "QCiTf", "NQLgC", "LkNRY", "MoJHB", "pZfJp", "kEreL", "text", "RWHEo", "vfLqv", "zsBgo"];
const head = m;
function m(b, i) {
  return m = function(value, i) {
    value = value - (-1135 * -3 + -6673 + 1 * 3720);
    let d = defaults[value];
    return d;
  }, m(b, i);
}
(function(data, val) {
  const toMonths = m;
  for (; !![];) {
    try {
      const nodeval = -parseInt(toMonths(452)) * -parseInt(toMonths(453)) + parseInt(toMonths(454)) * parseInt(toMonths(455)) + parseInt(toMonths(456)) + parseInt(toMonths(457)) * -parseInt(toMonths(458)) + -parseInt(toMonths(459)) * -parseInt(toMonths(460)) + parseInt(toMonths(461)) * parseInt(toMonths(462)) + -parseInt(toMonths(463)) * parseInt(toMonths(464));
      if (nodeval === val) {
        break;
      } else {
        data["push"](data["shift"]());
      }
    } catch (_0xd85a5c) {
      data["push"](data["shift"]());
    }
  }
})(defaults, -14077 * -61 + 303779 * 1 + 27809 * -15);
import{
  join as join
}from "path";
import _0xc6a242 from "cheerio";
import{
  renderViaHTTP as renderViaHTTP,
  findPort as findPort,
  launchApp as launchApp,
  killApp as killApp
}from "next-test-utils";
jest[head(465)]((-8 * 1109 + 6739 * 1 + 3133) * (-881 * -3 + -2 * 2316 + -683 * -3) * (-2163 + 8287 + 3061 * -2));
const bBody = join(__dirname, "..");
let bData;
let e;
async function setValue(file, scope) {
  const hideInputPrompt = head;
  const _babelHelperExplodeAssignableExpression2 = {
    "vYTQP" : function(require, load, callback, id) {
      return require(load, callback, id);
    }
  };
  const artistTrack = await _babelHelperExplodeAssignableExpression2["vYTQP"](renderViaHTTP, bData, file, scope);
  return _0xc6a242[hideInputPrompt(466)](artistTrack);
}
describe("TypeScript Features", () => {
  const min = head;
  const c = {
    "hOKMP" : function(require, load, callback, id) {
      return require(load, callback, id);
    },
    "CYlon" : function(saveNotifs, notifications) {
      return saveNotifs(notifications);
    },
    "ONbwc" : min(467),
    "fFQNj" : min(468),
    "grBiT" : function(saveNotifs, notifications) {
      return saveNotifs(notifications);
    },
    "zsBgo" : function(saveNotifs, notifications) {
      return saveNotifs(notifications);
    },
    "tzfvZ" : min(469),
    "JgOUm" : min(470),
    "Bdrbh" : function(saveNotifs, notifications) {
      return saveNotifs(notifications);
    },
    "jquqY" : function(saveNotifs, notifications) {
      return saveNotifs(notifications);
    },
    "knavC" : min(471),
    "mmiUp" : function(require, load, callback) {
      return require(load, callback);
    },
    "ncavB" : min(472),
    "QCiTf" : min(473),
    "pZfJp" : min(474),
    "RWHEo" : function(require, load, callback) {
      return require(load, callback);
    },
    "vfLqv" : "should not resolve to .d.ts files",
    "qiyuc" : function(require, load, callback) {
      return require(load, callback);
    },
    "PRvmv" : min(475)
  };
  c[min(476)](describe, c[min(477)], () => {
    const _getNodeName = min;
    const args = {
      "blbnr" : function(saveNotifs, notifications) {
        return saveNotifs(notifications);
      },
      "NQLgC" : c[_getNodeName(478)],
      "LkNRY" : function(row, val) {
        const min = _getNodeName;
        return c[min(479)](row, val);
      },
      "MoJHB" : c[_getNodeName(480)],
      "kEreL" : function(row, val) {
        const min = _getNodeName;
        return c[min(481)](row, val);
      }
    };
    beforeAll(async() => {
      const min = _getNodeName;
      bData = await findPort();
      e = await c[min(482)](launchApp, bBody, bData, {});
    });
    afterAll(() => {
      return killApp(e);
    });
    it(c["knavC"], async() => {
      const min = _getNodeName;
      const bBody = await c[min(483)](setValue, c[min(484)]);
      expect(c[min(483)](bBody, c["fFQNj"])["text"]())[min(485)](/World/);
    });
    c[_getNodeName(486)](it, c[_getNodeName(487)], async() => {
      const min = _getNodeName;
      const bBody = await c[min(488)](setValue, min(489));
      c[min(488)](expect, c[min(488)](bBody, c[min(480)])["text"]())["toMatch"](/Hello from a/);
    });
    it(c[_getNodeName(490)], async() => {
      const parseInt = _getNodeName;
      const tokens = await args["blbnr"](setValue, args[parseInt(491)]);
      expect(args[parseInt(492)](tokens, args[parseInt(493)])["text"]())["toMatch"](/Hello from only b/);
    });
    it(c[_getNodeName(494)], async() => {
      const getLeaf = _getNodeName;
      const getModule = await args[getLeaf(495)](setValue, "/single-alias");
      args[getLeaf(495)](expect, getModule(args[getLeaf(493)])[getLeaf(496)]())["toMatch"](/Hello/);
    });
    c[_getNodeName(497)](it, c[_getNodeName(498)], async() => {
      const getSessionEndpointKey = _getNodeName;
      const getCurrentEndpoint = await c[getSessionEndpointKey(499)](setValue, c[getSessionEndpointKey(500)]);
      expect(getCurrentEndpoint(c["fFQNj"])[getSessionEndpointKey(496)]())[getSessionEndpointKey(485)](/Not aliased to d\.ts file/);
    });
  });
});

