let repeat,baseToString,castSlice,hasUnicode,stringSize,stringToArray;_1e5‍.x([["default",()=>_1e5‍.o]]);_1e5‍.w("../repeat.js",[["default",["repeat"],function(v){repeat=v}]]);_1e5‍.w("./baseToString.js",[["default",["baseToString"],function(v){baseToString=v}]]);_1e5‍.w("./castSlice.js",[["default",["castSlice"],function(v){castSlice=v}]]);_1e5‍.w("./hasUnicode.js",[["default",["hasUnicode"],function(v){hasUnicode=v}]]);_1e5‍.w("./stringSize.js",[["default",["stringSize"],function(v){stringSize=v}]]);_1e5‍.w("./stringToArray.js",[["default",["stringToArray"],function(v){stringToArray=v}]]);






/**
 * Creates the padding for `string` based on `length`. The `chars` string
 * is truncated if the number of characters exceeds `length`.
 *
 * @private
 * @param {number} length The padding length.
 * @param {string} [chars=' '] The string used as padding.
 * @returns {string} Returns the padding for `string`.
 */
function createPadding(length, chars) {
  chars = chars === undefined ? ' ' : baseToString(chars)

  const charsLength = chars.length
  if (charsLength < 2) {
    return charsLength ? repeat(chars, length) : chars
  }
  const result = repeat(chars, Math.ceil(length / stringSize(chars)))
  return hasUnicode(chars)
    ? castSlice(stringToArray(result), 0, length).join('')
    : result.slice(0, length)
}

_1e5‍.d(createPadding);
