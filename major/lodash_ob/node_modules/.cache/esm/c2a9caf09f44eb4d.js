let assert,lodashStable,add,square,noop,identity,head,map,uniq,flow,flowRight;_9f4‍.w("assert",[["default",["assert"],function(v){assert=v}]]);_9f4‍.w("lodash",[["default",["lodashStable"],function(v){lodashStable=v}]]);_9f4‍.w("./utils.js",[["add",["add"],function(v){add=v}],["square",["square"],function(v){square=v}],["noop",["noop"],function(v){noop=v}],["identity",["identity"],function(v){identity=v}]]);_9f4‍.w("../head.js",[["default",["head"],function(v){head=v}]]);_9f4‍.w("../map.js",[["default",["map"],function(v){map=v}]]);_9f4‍.w("../uniq.js",[["default",["uniq"],function(v){uniq=v}]]);_9f4‍.w("../flow.js",[["default",["flow"],function(v){flow=v}]]);_9f4‍.w("../flowRight.js",[["default",["flowRight"],function(v){flowRight=v}]]);








const methods = {
  flow,
  flowRight
}

describe('flow methods', function() {
  lodashStable.each(['flow', 'flowRight'], function(methodName) {
    var func = methods[methodName],
        isFlow = methodName == 'flow';

    it('`_.' + methodName + '` should supply each function with the return value of the previous', function() {
      var fixed = function(n) { return n.toFixed(1); },
          combined = isFlow ? func(add, square, fixed) : func(fixed, square, add);

      assert.strictEqual(combined(1, 2), '9.0');
    });

    it('`_.' + methodName + '` should return a new function', function() {
      assert.notStrictEqual(func(noop), noop);
    });

    it('`_.' + methodName + '` should work with a curried function and `_.head`', function() {
      var curried = lodashStable.curry(identity);

      var combined = isFlow
        ? func(head, curried)
        : func(curried, head);

      assert.strictEqual(combined([1]), 1);
    });

    it('`_.' + methodName + '` should work with curried functions with placeholders', function() {
      var curried = lodashStable.curry(lodashStable.ary(map, 2), 2),
          getProp = curried(curried.placeholder, (value) => value.a),
          objects = [{ 'a': 1 }, { 'a': 2 }, { 'a': 1 }];

      var combined = isFlow
        ? func(getProp, uniq)
        : func(uniq, getProp);

      assert.deepStrictEqual(combined(objects), [1, 2]);
    });
  });
});
