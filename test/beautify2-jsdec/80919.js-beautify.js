"use strict";const npa=require("npm-package-arg");const path=require("path");const loadJsonFile=require("load-json-file");const writePkg=require("write-pkg");const PKG=Symbol("pkg");const _location=Symbol("location");const _resolved=Symbol("resolved");const _rootPath=Symbol("rootPath");const _scripts=Symbol("scripts");const _contents=Symbol("contents");function binSafeName({name,scope}){return scope?name.substring(scope.length+1):name}function shallowCopy(json){return Object.keys(json).reduce((obj,key)=>{const val=json[key];if(Array.isArray(val)){obj[key]=val.slice()}else if(val&&typeof val==="object"){obj[key]=Object.assign({},val)}else{obj[key]=val}return obj},{})}class Package{static lazy(ref,dir="."){if(typeof ref==="string"){const location=path.resolve(path.basename(ref)==="package.json"?path.dirname(ref):ref);const manifest=loadJsonFile.sync(path.join(location,"package.json"));return new Package(manifest,location)}if("__isLernaPackage"in ref){return ref}return new Package(ref,dir)}constructor(pkg,location,rootPath=location){const resolved=npa.resolve(pkg.name,`file:${path.relative(rootPath,location)}`,rootPath);this.name=pkg.name;this[PKG]=pkg;Object.defineProperty(this,PKG,{enumerable:false,writable:true});this[_location]=location;this[_resolved]=resolved;this[_rootPath]=rootPath;this[_scripts]={...pkg.scripts}}get location(){return this[_location]}get private(){return Boolean(this[PKG].private)}get resolved(){return this[_resolved]}get rootPath(){return this[_rootPath]}get scripts(){return this[_scripts]}get bin(){const pkg=this[PKG];return typeof pkg.bin==="string"?{[binSafeName(this.resolved)]:pkg.bin,}:Object.assign({},pkg.bin)}get binLocation(){return path.join(this.location,"node_modules",".bin")}get manifestLocation(){return path.join(this.location,"package.json")}get nodeModulesLocation(){return path.join(this.location,"node_modules")}get __isLernaPackage(){return true}get version(){return this[PKG].version}set version(version){this[PKG].version=version}get contents(){if(this[_contents]){return this[_contents]}if(this[PKG].publishConfig&&this[PKG].publishConfig.directory){return path.join(this.location,this[PKG].publishConfig.directory)}return this.location}set contents(subDirectory){this[_contents]=path.join(this.location,subDirectory)}get dependencies(){return this[PKG].dependencies}get devDependencies(){return this[PKG].devDependencies}get optionalDependencies(){return this[PKG].optionalDependencies}get peerDependencies(){return this[PKG].peerDependencies}get(key){return this[PKG][key]}set(key,val){this[PKG][key]=val;return this}toJSON(){return shallowCopy(this[PKG])}refresh(){return loadJsonFile(this.manifestLocation).then((pkg)=>{this[PKG]=pkg;return this})}serialize(){return writePkg(this.manifestLocation,this[PKG]).then(()=>this)}updateLocalDependency(resolved,depVersion,savePrefix){const depName=resolved.name;let depCollection=this.dependencies;if(!depCollection||!depCollection[depName]){depCollection=this.optionalDependencies}if(!depCollection||!depCollection[depName]){depCollection=this.devDependencies}if(resolved.registry||resolved.type==="directory"){depCollection[depName]=`${savePrefix}${depVersion}`}else if(resolved.gitCommittish){const[tagPrefix]=/^\D*/.exec(resolved.gitCommittish);const{hosted}=resolved;hosted.committish=`${tagPrefix}${depVersion}`;depCollection[depName]=hosted.toString({noGitPlus:false,noCommittish:false})}else if(resolved.gitRange){const{hosted}=resolved;hosted.committish=`semver:${savePrefix}${depVersion}`;depCollection[depName]=hosted.toString({noGitPlus:false,noCommittish:false})}}}module.exports.Package=Package;