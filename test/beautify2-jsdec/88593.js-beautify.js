const uuid=require("uuid");const{encode,decode}=require("arson");const{MESSAGE,RESPONSE,PING,PONG,}=require("./types.js");const hasOwn=Object.prototype.hasOwnProperty;Object.assign(exports,{enable(otherProcess){if(typeof otherProcess.onMessage==="function"&&typeof otherProcess.sendMessage==="function"){return otherProcess}const callbacksByTopic=new Map;otherProcess.onMessage=function onMessage(topic,callback){if(!callbacksByTopic.has(topic)){callbacksByTopic.set(topic,new Set)}callbacksByTopic.get(topic).add(callback)};const readyResolvers=new Map;const pendingMessages=new Map;const promisesByTopic=new Map;const handlersByType=Object.create(null);function gracefulErrorHandler(error){if(error&&error.code!=="EPIPE"){console.error("Error sending message:",error)}}handlersByType[PING]=function({id}){otherProcess.send({type:PONG,id},gracefulErrorHandler)};handlersByType[PONG]=function({id}){const resolve=readyResolvers.get(id);if(typeof resolve==="function"){readyResolvers.delete(id);resolve()}};handlersByType[MESSAGE]=function({responseId,topic,encodedPayload,}){const newPromise=(promisesByTopic.get(topic)||Promise.resolve()).then(()=>{const results=[];const callbacks=callbacksByTopic.get(topic);if(callbacks&&callbacks.size>0){callbacks.forEach(cb=>results.push(cb(decode(encodedPayload))));return Promise.all(results)}return results}).then(results=>{if(responseId){otherProcess.send({type:RESPONSE,responseId,encodedResults:encode(results),},gracefulErrorHandler)}},error=>{const serializable={};Reflect.ownKeys(error).forEach(key=>{serializable[key]=error[key]});otherProcess.send({type:RESPONSE,responseId,encodedError:encode(serializable),},gracefulErrorHandler)});promisesByTopic.set(topic,newPromise)};handlersByType[RESPONSE]=function(message){const entry=pendingMessages.get(message.responseId);if(entry){if(hasOwn.call(message,"encodedError")){entry.reject(decode(message.encodedError))}else{entry.resolve(decode(message.encodedResults))}}};otherProcess.on("message",message=>{const handler=handlersByType[message.type];if(typeof handler==="function"){handler(message)}});otherProcess.sendMessage=function sendMessage(topic,payload){otherProcess.readyForMessages=otherProcess.readyForMessages||makeReadyPromise();return otherProcess.readyForMessages.then(()=>{const responseId=uuid();return new Promise((resolve,reject)=>{pendingMessages.set(responseId,{resolve,reject});otherProcess.send({type:MESSAGE,responseId,topic,encodedPayload:encode(payload),},error=>{if(error){reject(error)}})}).then(response=>{pendingMessages.delete(responseId);return response},error=>{pendingMessages.delete(responseId);throw error})})};function makeReadyPromise(){return new Promise((resolve,reject)=>{const pingMessage={type:PING,id:uuid()};const backoff_factor=1.1;let delay_ms=50;readyResolvers.set(pingMessage.id,resolve);function poll(){if(readyResolvers.has(pingMessage.id)){otherProcess.send(pingMessage,error=>{if(error){reject(error)}else{setTimeout(poll,delay_ms);delay_ms*=backoff_factor}})}}poll()})}otherProcess.on("exit",(code,signal)=>{const error=new Error("process exited");Object.assign(error,{code,signal});pendingMessages.forEach(entry=>entry.reject(error));otherProcess.readyForMessages=Promise.reject(error);otherProcess.readyForMessages.catch(()=>{})});return otherProcess},onMessage(topic,callback){}});if(typeof process.send==="function"){exports.enable(process);exports.onMessage=process.onMessage}