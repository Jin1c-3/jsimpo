'use strict';
const _0x1e2c = [
    '8019RaJZDJ',
    '40QOJNHI',
    '238913WbuJaN',
    '419042MHloxk',
    '1NELmeF',
    '149873qvkDLf',
    '2NfzFkf',
    '1TvAUQf',
    '158398eWkEqD',
    'crypto',
    'sha256',
    'md5',
    'utf',
    'buf',
    'binary',
    'buffer',
    'legacy',
    'test',
    'version',
    'error',
    'Crypto\x20streams\x20not\x20available\x20until\x20v0.10',
    'asc',
    'repeat',
    'ascii',
    'utf8',
    'alloc',
    'unknown\x20message\x20type:\x20',
    'stream',
    'createHash',
    'update',
    'digest',
    'string',
    'from',
    'end',
    'setEncoding',
    'write',
    '1spQVnm',
    '602959KRMLsV',
    '1671AYNTno',
    '359yxGPpQ'
];
const _0x3d3183 = _0x3c2e;
(function (_0x5a3ce9, _0x5d2100) {
    const _0x46b789 = _0x3c2e;
    while (!![]) {
        try {
            const _0x12fd63 = parseInt(_0x46b789(0x1ba)) * parseInt(_0x46b789(0x1bb)) + parseInt(_0x46b789(0x1bc)) * -parseInt(_0x46b789(0x1bd)) + -parseInt(_0x46b789(0x1be)) * parseInt(_0x46b789(0x1bf)) + -parseInt(_0x46b789(0x1c0)) + parseInt(_0x46b789(0x1c1)) * parseInt(_0x46b789(0x1c2)) + parseInt(_0x46b789(0x1c3)) * parseInt(_0x46b789(0x1c4)) + -parseInt(_0x46b789(0x1c5)) * -parseInt(_0x46b789(0x1c6));
            if (_0x12fd63 === _0x5d2100)
                break;
            else
                _0x5a3ce9['push'](_0x5a3ce9['shift']());
        } catch (_0x5155aa) {
            _0x5a3ce9['push'](_0x5a3ce9['shift']());
        }
    }
}(_0x1e2c, 0x4e447));
function _0x3c2e(_0x5b0f0d, _0x2fba6a) {
    return _0x3c2e = function (_0x1e2c43, _0x3c2ec0) {
        _0x1e2c43 = _0x1e2c43 - 0x1ba;
        let _0x20987b = _0x1e2c[_0x1e2c43];
        return _0x20987b;
    }, _0x3c2e(_0x5b0f0d, _0x2fba6a);
}
const common = require('../common.js'), crypto = require(_0x3d3183(0x1c7)), bench = common['createBenchmark'](main, {
        'writes': [0x1f4],
        'algo': [
            _0x3d3183(0x1c8),
            _0x3d3183(0x1c9)
        ],
        'type': [
            'asc',
            _0x3d3183(0x1ca),
            _0x3d3183(0x1cb)
        ],
        'out': [
            'hex',
            _0x3d3183(0x1cc),
            _0x3d3183(0x1cd)
        ],
        'len': [
            0x2,
            0x400,
            0x19000,
            0x400 * 0x400
        ],
        'api': [
            _0x3d3183(0x1ce),
            'stream'
        ]
    });
function main({
    api: _0x535138,
    type: _0x58eba2,
    len: _0x2bbaa1,
    out: _0x70940b,
    writes: _0x254d29,
    algo: _0x2b72a5
}) {
    const _0x12841b = _0x3d3183;
    _0x535138 === 'stream' && /^v0\.[0-8]\./[_0x12841b(0x1cf)](process[_0x12841b(0x1d0)]) && (console[_0x12841b(0x1d1)](_0x12841b(0x1d2)), _0x535138 = _0x12841b(0x1ce));
    let _0x42578b, _0x862e4c;
    switch (_0x58eba2) {
    case _0x12841b(0x1d3):
        _0x42578b = 'a'[_0x12841b(0x1d4)](_0x2bbaa1), _0x862e4c = _0x12841b(0x1d5);
        break;
    case _0x12841b(0x1ca):
        _0x42578b = 'Ã¼'['repeat'](_0x2bbaa1 / 0x2), _0x862e4c = _0x12841b(0x1d6);
        break;
    case _0x12841b(0x1cb):
        _0x42578b = Buffer[_0x12841b(0x1d7)](_0x2bbaa1, 'b');
        break;
    default:
        throw new Error(_0x12841b(0x1d8) + _0x58eba2);
    }
    const _0x358b1d = _0x535138 === _0x12841b(0x1d9) ? streamWrite : legacyWrite;
    bench['start'](), _0x358b1d(_0x2b72a5, _0x42578b, _0x862e4c, _0x254d29, _0x2bbaa1, _0x70940b);
}
function legacyWrite(_0x4c655d, _0x758501, _0x25445b, _0x3c9e57, _0x9439dc, _0x490113) {
    const _0x283772 = _0x3d3183, _0x5192d3 = _0x3c9e57 * _0x9439dc, _0xeb438a = _0x5192d3 * 0x8, _0x3d8c59 = _0xeb438a / (0x400 * 0x400 * 0x400);
    while (_0x3c9e57-- > 0x0) {
        const _0xfc75e6 = crypto[_0x283772(0x1da)](_0x4c655d);
        _0xfc75e6[_0x283772(0x1db)](_0x758501, _0x25445b);
        let _0x4fec08 = _0xfc75e6[_0x283772(0x1dc)](_0x490113);
        if (_0x490113 === _0x283772(0x1cd) && typeof _0x4fec08 === _0x283772(0x1dd))
            _0x4fec08 = Buffer[_0x283772(0x1de)](_0x4fec08, _0x283772(0x1cc));
    }
    bench[_0x283772(0x1df)](_0x3d8c59);
}
function streamWrite(_0x967e55, _0x2cc746, _0x572e5d, _0x3d8a6d, _0x1d623d, _0x495f92) {
    const _0x153381 = _0x3d3183, _0x9f4358 = _0x3d8a6d * _0x1d623d, _0x2e48b8 = _0x9f4358 * 0x8, _0x4a644e = _0x2e48b8 / (0x400 * 0x400 * 0x400);
    while (_0x3d8a6d-- > 0x0) {
        const _0x13e91f = crypto[_0x153381(0x1da)](_0x967e55);
        if (_0x495f92 !== _0x153381(0x1cd))
            _0x13e91f[_0x153381(0x1e0)](_0x495f92);
        _0x13e91f[_0x153381(0x1e1)](_0x2cc746, _0x572e5d), _0x13e91f[_0x153381(0x1df)](), _0x13e91f['read']();
    }
    bench[_0x153381(0x1df)](_0x4a644e);
}
