"use strict";const createTree=require("functional-red-black-tree");const astUtils=require("./utils/ast-utils");const KNOWN_NODES=new Set(["AssignmentExpression","AssignmentPattern","ArrayExpression","ArrayPattern","ArrowFunctionExpression","AwaitExpression","BlockStatement","BinaryExpression","BreakStatement","CallExpression","CatchClause","ChainExpression","ClassBody","ClassDeclaration","ClassExpression","ConditionalExpression","ContinueStatement","DoWhileStatement","DebuggerStatement","EmptyStatement","ExperimentalRestProperty","ExperimentalSpreadProperty","ExpressionStatement","ForStatement","ForInStatement","ForOfStatement","FunctionDeclaration","FunctionExpression","Identifier","IfStatement","Literal","LabeledStatement","LogicalExpression","MemberExpression","MetaProperty","MethodDefinition","NewExpression","ObjectExpression","ObjectPattern","Program","Property","RestElement","ReturnStatement","SequenceExpression","SpreadElement","Super","SwitchCase","SwitchStatement","TaggedTemplateExpression","TemplateElement","TemplateLiteral","ThisExpression","ThrowStatement","TryStatement","UnaryExpression","UpdateExpression","VariableDeclaration","VariableDeclarator","WhileStatement","WithStatement","YieldExpression","JSXFragment","JSXOpeningFragment","JSXClosingFragment","JSXIdentifier","JSXNamespacedName","JSXMemberExpression","JSXEmptyExpression","JSXExpressionContainer","JSXElement","JSXClosingElement","JSXOpeningElement","JSXAttribute","JSXSpreadAttribute","JSXText","ExportDefaultDeclaration","ExportNamedDeclaration","ExportAllDeclaration","ExportSpecifier","ImportDeclaration","ImportSpecifier","ImportDefaultSpecifier","ImportNamespaceSpecifier","ImportExpression"]);class BinarySearchTree{constructor(){this._rbTree=createTree()}insert(e,t){const n=this._rbTree.find(e);if(n.valid){this._rbTree=n.update(t)}else{this._rbTree=this._rbTree.insert(e,t)}}findLe(e){const t=this._rbTree.le(e);return t&&{key:t.key,value:t.value}}deleteRange(e,t){if(e===t){return}const n=this._rbTree.ge(e);while(n.valid&&n.key<t){this._rbTree=this._rbTree.remove(n.key);n.next()}}}class TokenInfo{constructor(n){this.sourceCode=n;this.firstTokensByLineNumber=n.tokensAndComments.reduce((e,t)=>{if(!e.has(t.loc.start.line)){e.set(t.loc.start.line,t)}if(!e.has(t.loc.end.line)&&n.text.slice(t.range[1]-t.loc.end.column,t.range[1]).trim()){e.set(t.loc.end.line,t)}return e},new Map)}getFirstTokenOfLine(e){return this.firstTokensByLineNumber.get(e.loc.start.line)}isFirstTokenOfLine(e){return this.getFirstTokenOfLine(e)===e}getTokenIndent(e){return this.sourceCode.text.slice(e.range[0]-e.loc.start.column,e.range[0])}}class OffsetStorage{constructor(e,t,n){this._tokenInfo=e;this._indentSize=t;this._indentType=n;this._tree=new BinarySearchTree;this._tree.insert(0,{offset:0,from:null,force:false});this._lockedFirstTokens=new WeakMap;this._desiredIndentCache=new WeakMap;this._ignoredTokens=new WeakSet}_getOffsetDescriptor(e){return this._tree.findLe(e.range[0]).value}matchOffsetOf(e,t){this._lockedFirstTokens.set(t,e)}setDesiredOffset(e,t,n){return this.setDesiredOffsets(e.range,t,n)}setDesiredOffsets(e,t,n,s){const r={offset:n,from:t,force:s};const o=this._tree.findLe(e[1]).value;const i=t&&t.range[0]>=e[0]&&t.range[1]<=e[1];const a=i&&this._getOffsetDescriptor(t);this._tree.deleteRange(e[0]+1,e[1]);this._tree.insert(e[0],r);if(i){this._tree.insert(t.range[0],a);this._tree.insert(t.range[1],r)}this._tree.insert(e[1],o)}getDesiredIndent(e){if(!this._desiredIndentCache.has(e)){if(this._ignoredTokens.has(e)){this._desiredIndentCache.set(e,this._tokenInfo.getTokenIndent(e))}else if(this._lockedFirstTokens.has(e)){const t=this._lockedFirstTokens.get(e);this._desiredIndentCache.set(e,this.getDesiredIndent(this._tokenInfo.getFirstTokenOfLine(t))+this._indentType.repeat(t.loc.start.column-this._tokenInfo.getFirstTokenOfLine(t).loc.start.column))}else{const n=this._getOffsetDescriptor(e);const s=n.from&&n.from.loc.start.line===e.loc.start.line&&!/^\s*?\n/u.test(e.value)&&!n.force?0:n.offset*this._indentSize;this._desiredIndentCache.set(e,(n.from?this.getDesiredIndent(n.from):"")+this._indentType.repeat(s))}}return this._desiredIndentCache.get(e)}ignoreToken(e){if(this._tokenInfo.isFirstTokenOfLine(e)){this._ignoredTokens.add(e)}}getFirstDependency(e){return this._getOffsetDescriptor(e).from}}const ELEMENT_LIST_SCHEMA={oneOf:[{type:"integer",minimum:0},{enum:["first","off"]}]};module.exports={meta:{type:"layout",docs:{description:"enforce consistent indentation",category:"Stylistic Issues",recommended:false,url:"https://eslint.org/docs/rules/indent"},fixable:"whitespace",schema:[{oneOf:[{enum:["tab"]},{type:"integer",minimum:0}]},{type:"object",properties:{SwitchCase:{type:"integer",minimum:0,default:0},VariableDeclarator:{oneOf:[ELEMENT_LIST_SCHEMA,{type:"object",properties:{var:ELEMENT_LIST_SCHEMA,let:ELEMENT_LIST_SCHEMA,const:ELEMENT_LIST_SCHEMA},additionalProperties:false}]},outerIIFEBody:{oneOf:[{type:"integer",minimum:0},{enum:["off"]}]},MemberExpression:{oneOf:[{type:"integer",minimum:0},{enum:["off"]}]},FunctionDeclaration:{type:"object",properties:{parameters:ELEMENT_LIST_SCHEMA,body:{type:"integer",minimum:0}},additionalProperties:false},FunctionExpression:{type:"object",properties:{parameters:ELEMENT_LIST_SCHEMA,body:{type:"integer",minimum:0}},additionalProperties:false},CallExpression:{type:"object",properties:{arguments:ELEMENT_LIST_SCHEMA},additionalProperties:false},ArrayExpression:ELEMENT_LIST_SCHEMA,ObjectExpression:ELEMENT_LIST_SCHEMA,ImportDeclaration:ELEMENT_LIST_SCHEMA,flatTernaryExpressions:{type:"boolean",default:false},offsetTernaryExpressions:{type:"boolean",default:false},ignoredNodes:{type:"array",items:{type:"string",not:{pattern:":exit$"}}},ignoreComments:{type:"boolean",default:false}},additionalProperties:false}],messages:{wrongIndentation:"Expected indentation of {{expected}} but found {{actual}}."}},create(o){const r=1;const e=1;const t=1;let a="space";let n=4;const f={SwitchCase:0,VariableDeclarator:{var:r,let:r,const:r},outerIIFEBody:1,FunctionDeclaration:{parameters:e,body:t},FunctionExpression:{parameters:e,body:t},CallExpression:{arguments:e},MemberExpression:1,ArrayExpression:1,ObjectExpression:1,ImportDeclaration:1,flatTernaryExpressions:false,ignoredNodes:[],ignoreComments:false};if(o.options.length){if(o.options[0]==="tab"){n=1;a="tab"}else{n=o.options[0];a="space"}if(o.options[1]){Object.assign(f,o.options[1]);if(typeof f.VariableDeclarator==="number"||f.VariableDeclarator==="first"){f.VariableDeclarator={var:f.VariableDeclarator,let:f.VariableDeclarator,const:f.VariableDeclarator}}}}const g=o.getSourceCode();const c=new TokenInfo(g);const p=new OffsetStorage(c,n,a==="space"?" ":"\t");const d=new WeakSet;function i(e,t,n){const s=`${e} ${a}${e===1?"":"s"}`;const r=`space${t===1?"":"s"}`;const o=`tab${n===1?"":"s"}`;let i;if(t>0){i=a==="space"?t:`${t} ${r}`}else if(n>0){i=a==="tab"?n:`${n} ${o}`}else{i="0"}return{expected:s,actual:i}}function T(s,r){const e=Array.from(c.getTokenIndent(s));const t=e.filter(e=>e===" ").length;const n=e.filter(e=>e==="\t").length;o.report({node:s,messageId:"wrongIndentation",data:i(r.length,t,n),loc:{start:{line:s.loc.start.line,column:0},end:{line:s.loc.start.line,column:s.loc.start.column}},fix(e){const t=[s.range[0]-s.loc.start.column,s.range[0]];const n=r;return e.replaceTextRange(t,n)}})}function k(e,t){const n=c.getTokenIndent(e);return n===t||n.includes(" ")&&n.includes("\t")}function s(e){if(!e.parent||e.parent.type!=="CallExpression"||e.parent.callee!==e){return false}let t=e.parent&&e.parent.parent;while(t.type==="UnaryExpression"&&["!","~","+","-"].indexOf(t.operator)>-1||t.type==="AssignmentExpression"||t.type==="LogicalExpression"||t.type==="SequenceExpression"||t.type==="VariableDeclarator"){t=t.parent}return(t.type==="ExpressionStatement"||t.type==="VariableDeclaration")&&t.parent.type==="Program"}function m(e){const t=e.match(/\s*$/u)[0];const n=t.match(astUtils.createGlobalLinebreakMatcher());return n===null?0:n.length}function u(o,i,e,a){function l(e){let t=g.getTokenBefore(e);while(astUtils.isOpeningParenToken(t)&&t!==i){t=g.getTokenBefore(t)}return g.getTokenAfter(t)}p.setDesiredOffsets([i.range[1],e.range[0]],i,typeof a==="number"?a:1);p.setDesiredOffset(e,i,0);if(a==="first"&&o.length&&!o[0]){return}o.forEach((e,t)=>{if(!e){return}if(a==="off"){p.ignoreToken(l(e))}if(t===0){return}if(a==="first"&&c.isFirstTokenOfLine(l(e))){p.matchOffsetOf(l(o[0]),l(e))}else{const n=o[t-1];const s=n&&l(n);const r=n&&g.getLastToken(n);if(n&&r.loc.end.line-m(r.value)>i.loc.end.line){p.setDesiredOffsets([n.range[1],e.range[1]],s,0)}}})}function l(n){if(n.type!=="BlockStatement"){const s=g.getTokenBefore(n,astUtils.isNotOpeningParenToken);let e=g.getFirstToken(n);let t=g.getLastToken(n);while(astUtils.isOpeningParenToken(g.getTokenBefore(e))&&astUtils.isClosingParenToken(g.getTokenAfter(t))){e=g.getTokenBefore(e);t=g.getTokenAfter(t)}p.setDesiredOffsets([e.range[0],t.range[1]],s,1);const r=g.getLastToken(n);if(n.type!=="EmptyStatement"&&astUtils.isSemicolonToken(r)){p.setDesiredOffset(r,s,0)}}}function E(e){let t;if(e.arguments.length){t=g.getFirstTokenBetween(e.callee,e.arguments[0],astUtils.isOpeningParenToken)}else{t=g.getLastToken(e,1)}const n=g.getLastToken(e);d.add(t);d.add(n);if(e.optional){const o=g.getTokenAfter(e.callee,astUtils.isQuestionDotToken);const i=g.getTokensBetween(e.callee,o,{filter:astUtils.isClosingParenToken}).length;const a=i?g.getTokenBefore(e.callee,{skip:i-1}):g.getFirstToken(e.callee);const l=g.getTokenBefore(o);const c=l.loc.end.line===t.loc.start.line?l:a;p.setDesiredOffset(o,c,1)}const s=e.callee.type==="TaggedTemplateExpression"?g.getFirstToken(e.callee.quasi):t;const r=g.getTokenBefore(s);p.setDesiredOffset(t,r,0);u(e.arguments,t,n,f.CallExpression.arguments)}function h(e){const t=[];const n=[];e.forEach(e=>{if(astUtils.isOpeningParenToken(e)){t.push(e)}else if(astUtils.isClosingParenToken(e)){n.unshift({left:t.pop(),right:e})}});n.forEach(e=>{const t=e.left;const n=e.right;if(!d.has(t)&&!d.has(n)){const s=new Set(g.getTokensBetween(t,n));s.forEach(e=>{if(!s.has(p.getFirstDependency(e))){p.setDesiredOffset(e,t,1)}})}p.setDesiredOffset(n,t,0)})}function y(e){const n=new Set(g.getTokens(e,{includeComments:true}));n.forEach(e=>{if(!n.has(p.getFirstDependency(e))){const t=c.getFirstTokenOfLine(e);if(e===t){p.ignoreToken(e)}else{p.setDesiredOffset(e,t,0)}}})}function S(e,t){let n=t;while(n.parent&&!n.parent.type.endsWith("Statement")&&!n.parent.type.endsWith("Declaration")){n=n.parent}n=n.parent;return!n||n.loc.start.line===e.loc.start.line}function O(e,t){const n=e.loc.end.line;const s=t.loc.start.line;if(n===s||n===s-1){return false}for(let e=n+1;e<s;++e){if(!c.firstTokensByLineNumber.has(e)){return true}}return false}const D=new Set;const x={"ArrayExpression, ArrayPattern"(e){const t=g.getFirstToken(e);const n=g.getTokenAfter([...e.elements].reverse().find(e=>e)||t,astUtils.isClosingBracketToken);u(e.elements,t,n,f.ArrayExpression)},"ObjectExpression, ObjectPattern"(e){const t=g.getFirstToken(e);const n=g.getTokenAfter(e.properties.length?e.properties[e.properties.length-1]:t,astUtils.isClosingBraceToken);u(e.properties,t,n,f.ObjectExpression)},ArrowFunctionExpression(e){const t=g.getFirstToken(e,{skip:e.async?1:0});if(astUtils.isOpeningParenToken(t)){const n=t;const s=g.getTokenBefore(e.body,astUtils.isClosingParenToken);d.add(n);d.add(s);u(e.params,n,s,f.FunctionExpression.parameters)}l(e.body)},AssignmentExpression(t){const e=g.getFirstTokenBetween(t.left,t.right,e=>e.value===t.operator);p.setDesiredOffsets([e.range[0],t.range[1]],g.getLastToken(t.left),1);p.ignoreToken(e);p.ignoreToken(g.getTokenAfter(e))},"BinaryExpression, LogicalExpression"(t){const e=g.getFirstTokenBetween(t.left,t.right,e=>e.value===t.operator);const n=g.getTokenAfter(e);p.ignoreToken(e);p.ignoreToken(n);p.setDesiredOffset(n,e,0)},"BlockStatement, ClassBody"(e){let t;if(e.parent&&s(e.parent)){t=f.outerIIFEBody}else if(e.parent&&(e.parent.type==="FunctionExpression"||e.parent.type==="ArrowFunctionExpression")){t=f.FunctionExpression.body}else if(e.parent&&e.parent.type==="FunctionDeclaration"){t=f.FunctionDeclaration.body}else{t=1}if(!astUtils.STATEMENT_LIST_PARENTS.has(e.parent.type)){p.setDesiredOffset(g.getFirstToken(e),g.getFirstToken(e.parent),0)}u(e.body,g.getFirstToken(e),g.getLastToken(e),t)},CallExpression:E,"ClassDeclaration[superClass], ClassExpression[superClass]"(e){const t=g.getFirstToken(e);const n=g.getTokenBefore(e.superClass,astUtils.isNotOpeningParenToken);p.setDesiredOffsets([n.range[0],e.body.range[0]],t,1)},ConditionalExpression(e){const t=g.getFirstToken(e);if(!f.flatTernaryExpressions||!astUtils.isTokenOnSameLine(e.test,e.consequent)||S(t,e)){const n=g.getFirstTokenBetween(e.test,e.consequent,e=>e.type==="Punctuator"&&e.value==="?");const s=g.getFirstTokenBetween(e.consequent,e.alternate,e=>e.type==="Punctuator"&&e.value===":");const r=g.getTokenAfter(n);const o=g.getTokenBefore(s);const i=g.getTokenAfter(s);p.setDesiredOffset(n,t,1);p.setDesiredOffset(s,t,1);p.setDesiredOffset(r,t,r.type==="Punctuator"&&f.offsetTernaryExpressions?2:1);if(o.loc.end.line===i.loc.start.line){p.setDesiredOffset(i,r,0)}else{p.setDesiredOffset(i,t,i.type==="Punctuator"&&f.offsetTernaryExpressions?2:1)}}},"DoWhileStatement, WhileStatement, ForInStatement, ForOfStatement":e=>l(e.body),ExportNamedDeclaration(e){if(e.declaration===null){const t=g.getLastToken(e,astUtils.isClosingBraceToken);u(e.specifiers,g.getFirstToken(e,{skip:1}),t,1);if(e.source){p.setDesiredOffsets([t.range[1],e.range[1]],g.getFirstToken(e),1)}}},ForStatement(e){const t=g.getFirstToken(e,1);if(e.init){p.setDesiredOffsets(e.init.range,t,1)}if(e.test){p.setDesiredOffsets(e.test.range,t,1)}if(e.update){p.setDesiredOffsets(e.update.range,t,1)}l(e.body)},"FunctionDeclaration, FunctionExpression"(e){const t=g.getTokenBefore(e.body);const n=g.getTokenBefore(e.params.length?e.params[0]:t);d.add(n);d.add(t);u(e.params,n,t,f[e.type].parameters)},IfStatement(e){l(e.consequent);if(e.alternate&&e.alternate.type!=="IfStatement"){l(e.alternate)}},ImportDeclaration(e){if(e.specifiers.some(e=>e.type==="ImportSpecifier")){const r=g.getFirstToken(e,astUtils.isOpeningBraceToken);const o=g.getLastToken(e,astUtils.isClosingBraceToken);u(e.specifiers.filter(e=>e.type==="ImportSpecifier"),r,o,f.ImportDeclaration)}const t=g.getLastToken(e,e=>e.type==="Identifier"&&e.value==="from");const n=g.getLastToken(e,e=>e.type==="String");const s=g.getLastToken(e,e=>e.type==="Punctuator"&&e.value===";");if(t){const i=s&&s.range[1]===n.range[1]?e.range[1]:n.range[1];p.setDesiredOffsets([t.range[0],i],g.getFirstToken(e),1)}},ImportExpression(e){const t=g.getFirstToken(e,1);const n=g.getLastToken(e);d.add(t);d.add(n);p.setDesiredOffset(t,g.getTokenBefore(t),0);u([e.source],t,n,f.CallExpression.arguments)},"MemberExpression, JSXMemberExpression, MetaProperty"(e){const t=e.type==="MetaProperty"?e.meta:e.object;const n=g.getFirstTokenBetween(t,e.property,astUtils.isNotClosingParenToken);const s=g.getTokenAfter(n);const r=g.getTokensBetween(t,e.property,{filter:astUtils.isClosingParenToken}).length;const o=r?g.getTokenBefore(t,{skip:r-1}):g.getFirstToken(t);const i=g.getTokenBefore(n);const a=e.computed?n:s;if(e.computed){p.setDesiredOffset(g.getLastToken(e),n,0);p.setDesiredOffsets(e.property.range,n,1)}const l=i.loc.end.line===a.loc.start.line?i:o;if(typeof f.MemberExpression==="number"){p.setDesiredOffset(n,l,f.MemberExpression);p.setDesiredOffset(s,e.computed?n:l,f.MemberExpression)}else{p.ignoreToken(n);p.ignoreToken(s);p.setDesiredOffset(n,l,0);p.setDesiredOffset(s,n,0)}},NewExpression(e){if(e.arguments.length>0||astUtils.isClosingParenToken(g.getLastToken(e))&&astUtils.isOpeningParenToken(g.getLastToken(e,1))){E(e)}},Property(e){if(!e.shorthand&&!e.method&&e.kind==="init"){const t=g.getFirstTokenBetween(e.key,e.value,astUtils.isColonToken);p.ignoreToken(g.getTokenAfter(t))}},SwitchStatement(e){const t=g.getTokenAfter(e.discriminant,astUtils.isOpeningBraceToken);const n=g.getLastToken(e);p.setDesiredOffsets([t.range[1],n.range[0]],t,f.SwitchCase);if(e.cases.length){g.getTokensBetween(e.cases[e.cases.length-1],n,{includeComments:true,filter:astUtils.isCommentToken}).forEach(e=>p.ignoreToken(e))}},SwitchCase(e){if(!(e.consequent.length===1&&e.consequent[0].type==="BlockStatement")){const t=g.getFirstToken(e);const n=g.getTokenAfter(e);p.setDesiredOffsets([t.range[1],n.range[0]],t,1)}},TemplateLiteral(o){o.expressions.forEach((e,t)=>{const n=o.quasis[t];const s=o.quasis[t+1];const r=n.loc.start.line===n.loc.end.line?g.getFirstToken(n):null;p.setDesiredOffsets([n.range[1],s.range[0]],r,1);p.setDesiredOffset(g.getFirstToken(s),r,0)})},VariableDeclaration(e){let t=Object.prototype.hasOwnProperty.call(f.VariableDeclarator,e.kind)?f.VariableDeclarator[e.kind]:r;const n=g.getFirstToken(e),s=g.getLastToken(e);if(f.VariableDeclarator[e.kind]==="first"){if(e.declarations.length>1){u(e.declarations,n,s,"first");return}t=r}if(e.declarations[e.declarations.length-1].loc.start.line>e.loc.start.line){p.setDesiredOffsets(e.range,n,t,true)}else{p.setDesiredOffsets(e.range,n,t)}if(astUtils.isSemicolonToken(s)){p.ignoreToken(s)}},VariableDeclarator(e){if(e.init){const t=g.getTokenBefore(e.init,astUtils.isNotOpeningParenToken);const n=g.getTokenAfter(t);p.ignoreToken(t);p.ignoreToken(n);p.setDesiredOffsets([n.range[0],e.range[1]],t,1);p.setDesiredOffset(t,g.getLastToken(e.id),0)}},"JSXAttribute[value]"(e){const t=g.getFirstTokenBetween(e.name,e.value,e=>e.type==="Punctuator"&&e.value==="=");p.setDesiredOffsets([t.range[0],e.value.range[1]],g.getFirstToken(e.name),1)},JSXElement(e){if(e.closingElement){u(e.children,g.getFirstToken(e.openingElement),g.getFirstToken(e.closingElement),1)}},JSXOpeningElement(e){const t=g.getFirstToken(e);let n;if(e.selfClosing){n=g.getLastToken(e,{skip:1});p.setDesiredOffset(g.getLastToken(e),n,0)}else{n=g.getLastToken(e)}p.setDesiredOffsets(e.name.range,g.getFirstToken(e));u(e.attributes,t,n,1)},JSXClosingElement(e){const t=g.getFirstToken(e);p.setDesiredOffsets(e.name.range,t,1)},JSXFragment(e){const t=g.getFirstToken(e.openingFragment);const n=g.getFirstToken(e.closingFragment);u(e.children,t,n,1)},JSXOpeningFragment(e){const t=g.getFirstToken(e);const n=g.getLastToken(e);p.setDesiredOffsets(e.range,t,1);p.matchOffsetOf(t,n)},JSXClosingFragment(e){const t=g.getFirstToken(e);const n=g.getLastToken(e,{skip:1});const s=g.getLastToken(e);const r=astUtils.isTokenOnSameLine(n,s)?n:s;p.setDesiredOffsets(e.range,t,1);p.matchOffsetOf(t,r)},JSXExpressionContainer(e){const t=g.getFirstToken(e);const n=g.getLastToken(e);p.setDesiredOffsets([t.range[1],n.range[0]],t,1)},JSXSpreadAttribute(e){const t=g.getFirstToken(e);const n=g.getLastToken(e);p.setDesiredOffsets([t.range[1],n.range[0]],t,1)},"*"(e){const t=g.getFirstToken(e);if(t&&!D.has(t)){p.setDesiredOffsets(e.range,t,0)}}};const b=[];const F={};for(const[I,B]of Object.entries(x)){F[I]=e=>b.push({listener:B,node:e})}const L=new Set;function C(e){L.add(e);D.add(g.getFirstToken(e))}const _=f.ignoredNodes.reduce((e,t)=>Object.assign(e,{[t]:C}),{});return Object.assign(F,_,{"*:exit"(e){if(!KNOWN_NODES.has(e.type)){C(e)}},"Program:exit"(){if(f.ignoreComments){g.getAllComments().forEach(e=>p.ignoreToken(e))}b.filter(e=>!L.has(e.node)).forEach(e=>e.listener(e.node));L.forEach(y);h(g.ast.tokens);const l=g.ast.comments.reduce((e,t)=>{const n=g.getTokenBefore(t,{includeComments:true});return e.set(t,e.has(n)?e.get(n):n)},new WeakMap);g.lines.forEach((e,t)=>{const n=t+1;if(!c.firstTokensByLineNumber.has(n)){return}const s=c.firstTokensByLineNumber.get(n);if(s.loc.start.line!==n){return}if(astUtils.isCommentToken(s)){const r=l.get(s);const o=r?g.getTokenAfter(r):g.ast.tokens[0];const i=r&&!O(r,s);const a=o&&!O(s,o);if(o&&astUtils.isSemicolonToken(o)&&!astUtils.isTokenOnSameLine(s,o)){p.setDesiredOffset(s,o,0)}if(i&&k(s,p.getDesiredIndent(r))||a&&k(s,p.getDesiredIndent(o))){return}}if(k(s,p.getDesiredIndent(s))){return}T(s,p.getDesiredIndent(s))})}})}};