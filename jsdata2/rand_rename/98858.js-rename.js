"use strict";const _=require("lodash");const chai=require("chai");const path=require("path");const fs=require("fs-extra");const os=require("os");const proxyquire=require("proxyquire");const sinon=require("sinon");const overrideEnv=require("process-utils/override-env");const AwsProvider=require("../../../../../lib/plugins/aws/provider");const Serverless=require("../../../../../lib/Serverless");const runServerless=require("../../../../utils/run-serverless");chai.use(require("chai-as-promised"));chai.use(require("sinon-chai"));const expect=chai.expect;describe("AwsProvider",()=>{let a;let o;let e;const i={stage:"dev",region:"us-east-1"};beforeEach(()=>{({restoreEnv:e}=overrideEnv());o=new Serverless(i);o.cli=new o.classes.CLI;a=new AwsProvider(o,i)});afterEach(()=>e());describe("#constructor()",()=>{it("should set Serverless instance",()=>{expect(typeof a.serverless).to.not.equal("undefined")});it("should set the provider property",()=>{expect(a.provider).to.equal(a)});describe("stage name validation",()=>{const e=["myStage","my-stage","my_stage","${opt:stage, 'prod'}"];e.forEach(s=>{it(`should not throw an error before variable population
            even if http event is present and stage is ${s}`,()=>{const e={stage:s};o=new Serverless(e);const t={service:"new-service",provider:{name:"aws",stage:s},functions:{first:{events:[{http:{path:"foo",method:"GET"}}]}}};o.service=new o.classes.Service(o,t);expect(()=>new AwsProvider(o,e)).to.not.throw(Error)})})});describe("deploymentBucket configuration",()=>{it("should do nothing if not defined",()=>{o.service.provider.deploymentBucket=undefined;const e=new AwsProvider(o,i);expect(e.serverless.service.provider.deploymentBucket).to.equal(undefined)});it("should do nothing if the value is a string",()=>{o.service.provider.deploymentBucket="my.deployment.bucket";const e=new AwsProvider(o,i);expect(e.serverless.service.provider.deploymentBucket).to.equal("my.deployment.bucket")})})});describe("values",()=>{const e={a:"b",c:{d:"e",f:{g:"h"}}};const t=[["a"],["c","d"],["c","f","g"]];const s=[{path:t[0],value:e.a},{path:t[1],value:e.c.d},{path:t[2],value:e.c.f.g}];describe("#getValues",()=>{it("should return an array of values given paths to them",()=>{expect(a.getValues(e,t)).to.eql(s)})});describe("#firstValue",()=>{it("should ignore entries without a 'value' attribute",()=>{const e=_.cloneDeep(s);delete e[0].value;delete e[2].value;expect(a.firstValue(e)).to.eql(s[1])});it("should ignore entries with an undefined 'value' attribute",()=>{const e=_.cloneDeep(s);e[0].value=undefined;e[2].value=undefined;expect(a.firstValue(e)).to.eql(s[1])});it("should return the first value",()=>{expect(a.firstValue(s)).to.equal(s[0])});it("should return the middle value",()=>{const e=_.cloneDeep(s);delete e[0].value;delete e[2].value;expect(a.firstValue(e)).to.equal(e[1])});it("should return the last value",()=>{const e=_.cloneDeep(s);delete e[0].value;delete e[1].value;expect(a.firstValue(e)).to.equal(e[2])});it("should return the last object if none have valid values",()=>{const e=_.cloneDeep(s);delete e[0].value;delete e[1].value;delete e[2].value;expect(a.firstValue(e)).to.equal(e[2])})})});describe("#request()",()=>{let t;let s;let r;beforeEach(()=>{r=sinon.stub();t=sinon.stub().resolves();t.memoized=sinon.stub().resolves();const e=proxyquire.noCallThru().load("../../../../../lib/plugins/aws/provider.js",{"../../aws/request":t,"@serverless/utils/log":r});s=new e(o,i)});afterEach(()=>{});it("should pass resolved credentials as expected",async()=>{s.cachedCredentials={accessKeyId:"accessKeyId",secretAccessKey:"secretAccessKey",sessionToken:"sessionToken"};await s.request("S3","getObject",{});expect(t.args[0][0]).to.deep.equal({name:"S3",params:{...s.cachedCredentials,region:"us-east-1",isS3TransferAccelerationEnabled:false}})});it("should trigger the expected AWS SDK invokation",()=>{return s.request("S3","getObject",{}).then(()=>{expect(t).to.have.been.calledOnce})});it("should use local cache when using {useCache: true}",()=>{return s.request("S3","getObject",{},{useCache:true}).then(()=>s.request("S3","getObject",{},{useCache:true})).then(()=>{expect(t).to.not.have.been.called;expect(t.memoized).to.have.been.calledTwice})});it("should detect incompatible legacy use of aws request and print a debug warning",()=>{process.env.SLS_DEBUG=true;return s.request("S3","getObject",{},"incompatible string option").then(()=>{expect(r).to.have.been.calledWith("WARNING: Inappropriate call of provider.request()")}).finally(()=>{process.env.SLS_DEBUG=false})})});describe("#getServerlessDeploymentBucketName()",()=>{it("should return the name of the serverless deployment bucket",()=>{const t=sinon.stub(a,"request").resolves({StackResourceDetail:{PhysicalResourceId:"serverlessDeploymentBucketName"}});return a.getServerlessDeploymentBucketName().then(e=>{expect(e).to.equal("serverlessDeploymentBucketName");expect(t.calledOnce).to.be.equal(true);expect(t.calledWithExactly("CloudFormation","describeStackResource",{StackName:a.naming.getStackName(),LogicalResourceId:a.naming.getDeploymentBucketLogicalId()})).to.be.equal(true);a.request.restore()})});it("should return the name of the custom deployment bucket",()=>{a.serverless.service.provider.deploymentBucket="custom-bucket";const t=sinon.stub(a,"request").resolves({StackResourceDetail:{PhysicalResourceId:"serverlessDeploymentBucketName"}});return a.getServerlessDeploymentBucketName().then(e=>{expect(t.called).to.be.equal(false);expect(e).to.equal("custom-bucket");a.request.restore()})})});describe("#getAccountInfo()",()=>{it("should return the AWS account id and partition",()=>{const t="12345678";const s="aws";const r=sinon.stub(a,"request").resolves({ResponseMetadata:{RequestId:"12345678-1234-1234-1234-123456789012"},UserId:"ABCDEFGHIJKLMNOPQRSTU:VWXYZ",Account:t,Arn:"arn:aws:sts::123456789012:assumed-role/ROLE-NAME/VWXYZ"});return a.getAccountInfo().then(e=>{expect(r.calledOnce).to.equal(true);expect(e.accountId).to.equal(t);expect(e.partition).to.equal(s);a.request.restore()})})});describe("#getAccountId()",()=>{it("should return the AWS account id",()=>{const t="12345678";const s=sinon.stub(a,"request").resolves({ResponseMetadata:{RequestId:"12345678-1234-1234-1234-123456789012"},UserId:"ABCDEFGHIJKLMNOPQRSTU:VWXYZ",Account:t,Arn:"arn:aws:sts::123456789012:assumed-role/ROLE-NAME/VWXYZ"});return a.getAccountId().then(e=>{expect(s.calledOnce).to.equal(true);expect(e).to.equal(t);a.request.restore()})})});describe("#isS3TransferAccelerationEnabled()",()=>{it("should return false by default",()=>{a.options["aws-s3-accelerate"]=undefined;return expect(a.isS3TransferAccelerationEnabled()).to.equal(false)});it("should return true when CLI option is provided",()=>{a.options["aws-s3-accelerate"]=true;return expect(a.isS3TransferAccelerationEnabled()).to.equal(true)})});describe("#disableTransferAccelerationForCurrentDeploy()",()=>{it("should remove the corresponding option for the current deploy",()=>{a.options["aws-s3-accelerate"]=true;a.disableTransferAccelerationForCurrentDeploy();return expect(a.options["aws-s3-accelerate"]).to.be.undefined})})});describe("test/unit/lib/plugins/aws/provider.test.js",()=>{describe("#getProviderName and #sessionCache",()=>{let i;const c="123";before(async()=>{class e{constructor(e){this.credentials=e;this.credentials.credentials.sessionToken=c}describeStacks(){return{promise:async()=>{}}}}class t{constructor(){this.sessionToken="abc";this.accessKeyId="keyId";this.secretAccessKey="secret"}}class s{constructor(){this.sessionToken="env";this.accessKeyId="keyId";this.secretAccessKey="secret"}}class r{}const a={"aws-sdk":{SharedIniFileCredentials:t,EnvironmentCredentials:s,CloudFormation:e},"aws-sdk/lib/metadata_service":r};const{serverless:o}=await runServerless({fixture:"aws",command:"print",modulesCacheStub:a});i=o});it("`AwsProvider.getProviderName()` should resolve provider name",()=>{expect(AwsProvider.getProviderName()).to.equal("aws")});it("should retain sessionToken eventually updated internally by SDK",async()=>{expect(i.getProvider("aws").getCredentials().credentials.sessionToken).not.to.equal(c);await i.getProvider("aws").request("CloudFormation","describeStacks");expect(i.getProvider("aws").getCredentials().credentials.sessionToken).to.equal(c)})});describe("#getCredentials()",()=>{before(async()=>{await fs.ensureDir(path.resolve(os.homedir(),"./.aws"));await fs.outputFile(path.resolve(os.homedir(),"./.aws/credentials"),`
[default]
aws_access_key_id = DEFAULTKEYID
aws_secret_access_key = DEFAULTSECRET

[notDefault]
aws_access_key_id = NOTDEFAULTKEYID
aws_secret_access_key = NOTDEFAULTSECRET

[notDefaultWithRole]
source_profile = notDefault
role_arn = NOTDEFAULTWITHROLEROLE
`,{flag:"w+"})});it("should get credentials from default AWS profile",async()=>{const{serverless:e}=await runServerless({fixture:"aws",command:"print"});const t=e.getProvider("aws").getCredentials();expect(t.credentials.accessKeyId).to.equal("DEFAULTKEYID")});it("should get credentials from custom default AWS profile, set by AWS_DEFAULT_PROFILE",async()=>{const{serverless:e}=await runServerless({fixture:"aws",command:"print"});let t;overrideEnv(()=>{process.env.AWS_DEFAULT_PROFILE="notDefault";t=e.getProvider("aws").getCredentials()});expect(t.credentials.accessKeyId).to.equal("NOTDEFAULTKEYID")});describe("assume role with provider.profile",()=>{let t;before(async()=>{const{serverless:e}=await runServerless({fixture:"aws",command:"print",configExt:{provider:{profile:"notDefaultWithRole"}}});t=e.getProvider("aws").getCredentials()});it("should get credentials from `provider.profile`",()=>{expect(t.credentials.profile).to.equal("notDefaultWithRole")});it("should accept a role to assume on credentials",()=>{expect(t.credentials.roleArn).to.equal("NOTDEFAULTWITHROLEROLE")})});it("should get credentials from environment variables",async()=>{const{serverless:e}=await runServerless({fixture:"aws",command:"print"});let t;overrideEnv(()=>{process.env.AWS_ACCESS_KEY_ID="ENVKEYID";process.env.AWS_SECRET_ACCESS_KEY="ENVSECRET";t=e.getProvider("aws").getCredentials()});expect(t.credentials.accessKeyId).to.equal("ENVKEYID")});describe("profile with non default credentials file",()=>{let t;before(async()=>{await fs.outputFile(path.resolve(os.homedir(),"./custom_credentials"),`
[default]
aws_access_key_id = DEFAULTKEYID
aws_secret_access_key = DEFAULTSECRET

[customProfile]
aws_access_key_id = CUSTOMKEYID
aws_secret_access_key = CUSTOMSECRET
`,{flag:"w+"});const{serverless:e}=await runServerless({fixture:"aws",command:"print"});overrideEnv(()=>{process.env.AWS_PROFILE="customProfile";process.env.AWS_SHARED_CREDENTIALS_FILE=path.resolve(os.homedir(),"./custom_credentials").toString();t=e.getProvider("aws").getCredentials()})});after(async()=>{await fs.remove(path.resolve(os.homedir(),"./custom_credentials"))});it("should get credentials from AWS_PROFILE environment variable",()=>{expect(t.credentials.profile).to.equal("customProfile")});it("should get credentials from AWS_SHARED_CREDENTIALS_FILE environment variable",()=>{expect(t.credentials.accessKeyId).to.equal("CUSTOMKEYID")})});it("should get credentials from stage specific environment variables",async()=>{const{serverless:e}=await runServerless({fixture:"aws",command:"print",configExt:{provider:{stage:"testStage"}}});let t;overrideEnv(()=>{process.env.AWS_TESTSTAGE_ACCESS_KEY_ID="TESTSTAGEACCESSKEYID";process.env.AWS_TESTSTAGE_SECRET_ACCESS_KEY="TESTSTAGESECRET";t=e.getProvider("aws").getCredentials()});expect(t.credentials.accessKeyId).to.equal("TESTSTAGEACCESSKEYID")});it("should get credentials from AWS_{stage}_PROFILE environment variable",async()=>{const{serverless:e}=await runServerless({fixture:"aws",command:"print",configExt:{provider:{stage:"testStage"}}});let t;overrideEnv(()=>{process.env.AWS_TESTSTAGE_PROFILE="notDefault";t=e.getProvider("aws").getCredentials()});expect(t.credentials.accessKeyId).to.equal("NOTDEFAULTKEYID")});describe("profile with cli and encryption",()=>{let t;before(async()=>{const{serverless:e}=await runServerless({fixture:"aws",command:"print",options:{"aws-profile":"notDefault"},configExt:{provider:{deploymentBucket:{serverSideEncryption:"aws:kms"}}}});t=e.getProvider("aws").getCredentials()});it('should get credentials "--aws-profile" CLI option',()=>{expect(t.credentials.accessKeyId).to.equal("NOTDEFAULTKEYID")});it("should set the signatureVersion to v4 if the serverSideEncryption is aws:kms",()=>{expect(t.signatureVersion).to.equal("v4")})});it("should throw an error if a non-existent profile is set",async()=>{const{serverless:e}=await runServerless({fixture:"aws",command:"print",options:{"aws-profile":"nonExistent"}});expect(()=>e.getProvider("aws").getCredentials()).to.throw(Error)})});describe("#getRegion()",()=>{it('should default to "us-east-1"',async()=>{const{serverless:e}=await runServerless({fixture:"aws",command:"print"});expect(e.getProvider("aws").getRegion()).to.equal("us-east-1")});it("should allow to override via `provider.region`",async()=>{const{serverless:e}=await runServerless({fixture:"aws",command:"print",configExt:{provider:{region:"eu-central-1"}}});expect(e.getProvider("aws").getRegion()).to.equal("eu-central-1")});it("should allow to override via CLI `--region` param",async()=>{const{serverless:e}=await runServerless({fixture:"aws",command:"print",options:{region:"us-west-1"},configExt:{provider:{region:"eu-central-1"}}});expect(e.getProvider("aws").getRegion()).to.equal("us-west-1")})});describe("#getProfile()",()=>{it("should allow to set via `provider.profile`",async()=>{const{serverless:e}=await runServerless({fixture:"aws",command:"print",configExt:{provider:{profile:"test-profile"}}});expect(e.getProvider("aws").getProfile()).to.equal("test-profile")});it("should allow to set via CLI `--profile` param",async()=>{const{serverless:e}=await runServerless({fixture:"aws",command:"print",options:{profile:"cli-override"},configExt:{provider:{profile:"test-profile"}}});expect(e.getProvider("aws").getProfile()).to.equal("cli-override")});it("should allow to set via CLI `--aws-profile` param",async()=>{const{serverless:e}=await runServerless({fixture:"aws",command:"print",options:{profile:"cli-override","aws-profile":"aws-override"},configExt:{provider:{profile:"test-profile"}}});expect(e.getProvider("aws").getProfile()).to.equal("aws-override")})});describe("#getDeploymentPrefix()",()=>{it("should put all artifacts in namespaced folder",async()=>{const{cfTemplate:e}=await runServerless({fixture:"function",command:"package"});const t=Object.values(e.Resources).filter(e=>e.Type==="AWS::Lambda::Function");expect(t.length).to.be.greaterThanOrEqual(1);for(const s of t){expect(s.Properties.Code.S3Key).to.be.a("string").and.satisfy(e=>e.startsWith("serverless/"))}});it("should support custom namespaced folder",async()=>{const{cfTemplate:e}=await runServerless({fixture:"function",command:"package",configExt:{provider:{deploymentPrefix:"test-prefix"}}});const t=Object.values(e.Resources).filter(e=>e.Type==="AWS::Lambda::Function");expect(t.length).to.be.greaterThanOrEqual(1);for(const s of t){expect(s.Properties.Code.S3Key).to.be.a("string").and.satisfy(e=>e.startsWith("test-prefix/"))}})});describe("#getAlbTargetGroupPrefix()",()=>{it("should support `provider.alb.targetGroupPrefix`",async()=>{const e="50dc6c495c0c9188";const t={listenerArn:`arn:aws:elasticloadbalancing:us-east-1:123456789012:listener/app/my-load-balancer/${e}/f2f7dc8efc522ab2`,conditions:{path:"/"}};const{cfTemplate:s}=await runServerless({fixture:"function",command:"package",configExt:{provider:{alb:{targetGroupPrefix:"a-prefix"}},functions:{fnTargetGroupName:{handler:"index.handler",events:[{alb:{...t,priority:1}}]}}}});const r=Object.values(s.Resources).filter(e=>e.Type==="AWS::ElasticLoadBalancingV2::TargetGroup");expect(r.length).to.be.greaterThanOrEqual(1);for(const a of r){expect(a.Properties.Name).to.be.a("string").and.satisfy(e=>e.startsWith("a-prefix"))}})});describe("#getStage()",()=>{it('should default to "dev"',async()=>{const{serverless:e}=await runServerless({fixture:"aws",command:"print"});expect(e.getProvider("aws").getStage()).to.equal("dev")});it("should allow to override via `provider.stage`",async()=>{const{serverless:e}=await runServerless({fixture:"aws",command:"print",configExt:{provider:{stage:"staging"}}});expect(e.getProvider("aws").getStage()).to.equal("staging")});it("should allow to override via CLI `--stage` param",async()=>{const{serverless:e}=await runServerless({fixture:"aws",command:"print",options:{stage:"production"},configExt:{provider:{stage:"staging"}}});expect(e.getProvider("aws").getStage()).to.equal("production")})});describe("when resolving images",()=>{it("should fail if `functions[].image` references image with both path and uri",async()=>{await expect(runServerless({fixture:"function",command:"package",configExt:{provider:{ecr:{images:{invalidimage:{path:"./",uri:"000000000000.dkr.ecr.sa-east-1.amazonaws.com/test-lambda-docker@sha256:6bb600b4d6e1d7cf521097177dd0c4e9ea373edb91984a505333be8ac9455d38"}}}},functions:{fnProviderInvalidImage:{image:"invalidimage"}}}})).to.be.eventually.rejected.and.have.property("code","ECR_IMAGE_BOTH_URI_AND_PATH_DEFINED_ERROR")});it("should fail if `functions[].image` references image without path and uri",async()=>{await expect(runServerless({fixture:"function",command:"package",configExt:{provider:{ecr:{images:{invalidimage:{}}}},functions:{fnProviderInvalidImage:{image:"invalidimage"}}}})).to.be.eventually.rejected.and.have.property("code","ECR_IMAGE_NEITHER_URI_NOR_PATH_DEFINED_ERROR")});it("should fail if `functions[].image` references image from `provider.ecr.images` that has invalid path",async()=>{await expect(runServerless({fixture:"ecr",command:"package",shouldStubSpawn:true,configExt:{provider:{ecr:{images:{baseimage:{path:"./invalid"}}}}}})).to.be.eventually.rejected.and.have.property("code","DOCKERFILE_NOT_AVAILABLE_ERROR")});it("should fail if `functions[].image` references image not defined in `provider.ecr.images`",async()=>{await expect(runServerless({fixture:"function",command:"package",configExt:{functions:{fnInvalid:{image:"undefinedimage"}}}})).to.be.eventually.rejected.and.have.property("code","REFERENCED_FUNCTION_IMAGE_NOT_DEFINED_IN_PROVIDER")});it("should fail if both uri and name is provided for an image",async()=>{await expect(runServerless({fixture:"ecr",command:"package",shouldStubSpawn:true,configExt:{functions:{foo:{image:{name:"baseimage",uri:"000000000000.dkr.ecr.sa-east-1.amazonaws.com/test-lambda-docker@sha256:6bb600b4d6e1d7cf521097177dd0c4e9ea373edb91984a505333be8ac9455d38"}}}}})).to.be.eventually.rejected.and.have.property("code","FUNCTION_IMAGE_BOTH_URI_AND_NAME_DEFINED_ERROR")});it("should fail if neither uri nor name is provided for an image",async()=>{await expect(runServerless({fixture:"ecr",command:"package",shouldStubSpawn:true,configExt:{functions:{foo:{image:{}}}}})).to.be.eventually.rejected.and.have.property("code","FUNCTION_IMAGE_NEITHER_URI_NOR_NAME_DEFINED_ERROR")});const g=(e,t)=>Object.values(e).find(e=>e.Type==="AWS::Lambda::Version"&&e.Properties.FunctionName.Ref===t).Properties;describe("with `functions[].image` referencing existing images",()=>{let i;let c;let n;const r="6bb600b4d6e1d7cf521097177dd0c4e9ea373edb91984a505333be8ac9455d38";const a=`000000000000.dkr.ecr.sa-east-1.amazonaws.com/test-lambda-docker@sha256:${r}`;const o="sha256:2e6b10a4b1ca0f6d3563a8a1f034dde7c4d7c93b50aa91f24311765d0822186b";const l=sinon.stub().resolves({imageDetails:[{imageDigest:o}]});const d={ECR:{describeImages:l}};before(async()=>{const{awsNaming:e,cfTemplate:t,fixtureData:s}=await runServerless({fixture:"function",command:"package",configExt:{provider:{ecr:{images:{imagewithexplicituri:{uri:a},imagewithimplicituri:a}}},functions:{fnImage:{image:a},fnImageWithTag:{image:"000000000000.dkr.ecr.sa-east-1.amazonaws.com/test-lambda-docker:stable"},fnImageWithTagAndRepoWithSlashes:{image:"000000000000.dkr.ecr.sa-east-1.amazonaws.com/test-lambda/repo-docker:stable"},fnImageWithExplicitUri:{image:{uri:a}},fnProviderImageWithExplicitUri:{image:"imagewithexplicituri"},fnProviderImageWithImplicitUri:{image:"imagewithimplicituri"}}},awsRequestStubMap:d});i=t.Resources;c=e;n=s.serviceConfig});it("should support `functions[].image` with implicit uri with sha",()=>{const e=n.functions.fnImage;const t=c.getLambdaLogicalId("fnImage");const s=i[t].Properties;expect(s.Code).to.deep.equal({ImageUri:e.image});expect(s).to.not.have.property("Handler");expect(s).to.not.have.property("Runtime");const r=e.image.slice(e.image.lastIndexOf("@")+1);expect(r).to.match(/^sha256:[a-f0-9]{64}$/);const a=r.slice("sha256:".length);const o=g(i,t);expect(o.CodeSha256).to.equal(a)});it("should support `functions[].image` with explicit uri with sha",()=>{const e=n.functions.fnImageWithExplicitUri;const t=c.getLambdaLogicalId("fnImageWithExplicitUri");const s=i[t].Properties;expect(s.Code).to.deep.equal({ImageUri:e.image.uri});expect(s).to.not.have.property("Handler");expect(s).to.not.have.property("Runtime");const r=e.image.uri.slice(e.image.uri.lastIndexOf("@")+1);expect(r).to.match(/^sha256:[a-f0-9]{64}$/);const a=r.slice("sha256:".length);const o=g(i,t);expect(o.CodeSha256).to.equal(a)});it("should support `functions[].image` with tag",()=>{const e=n.functions.fnImageWithTag;const t=c.getLambdaLogicalId("fnImageWithTag");const s=i[t].Properties;expect(s.Code).to.deep.equal({ImageUri:`${e.image.split(":")[0]}@${o}`});expect(s).to.not.have.property("Handler");expect(s).to.not.have.property("Runtime");const r=g(i,t);expect(r.CodeSha256).to.equal(o.slice("sha256:".length));expect(l).to.be.calledWith({imageIds:[{imageTag:"stable"}],registryId:"000000000000",repositoryName:"test-lambda-docker"})});it("should support `functions[].image` with tag and repository name with slash",()=>{const e=n.functions.fnImageWithTagAndRepoWithSlashes;const t=c.getLambdaLogicalId("fnImageWithTagAndRepoWithSlashes");const s=i[t].Properties;expect(s.Code).to.deep.equal({ImageUri:`${e.image.split(":")[0]}@${o}`});expect(s).to.not.have.property("Handler");expect(s).to.not.have.property("Runtime");const r=g(i,t);expect(r.CodeSha256).to.equal(o.slice("sha256:".length));expect(l).to.be.calledWith({imageIds:[{imageTag:"stable"}],registryId:"000000000000",repositoryName:"test-lambda/repo-docker"})});it("should support `functions[].image` that references provider.ecr.images defined with explicit uri",()=>{const e=c.getLambdaLogicalId("fnProviderImageWithExplicitUri");const t=i[e].Properties;expect(t.Code).to.deep.equal({ImageUri:a});expect(t).to.not.have.property("Handler");expect(t).to.not.have.property("Runtime");const s=g(i,e);expect(s.CodeSha256).to.equal(r)});it("should support `functions[].image` that references provider.ecr.images defined with implicit uri",()=>{const e=c.getLambdaLogicalId("fnProviderImageWithImplicitUri");const t=i[e].Properties;expect(t.Code).to.deep.equal({ImageUri:a});expect(t).to.not.have.property("Handler");expect(t).to.not.have.property("Runtime");const s=g(i,e);expect(s.CodeSha256).to.equal(r)})});describe("with `functions[].image` referencing images that require building",()=>{const n="6bb600b4d6e1d7cf521097177dd0c4e9ea373edb91984a505333be8ac9455d38";const l="999999999999.dkr.ecr.sa-east-1.amazonaws.com/test-lambda-docker";const e="YXdzOmRvY2tlcmF1dGh0b2tlbg==";const d=`https://${l}`;const u=sinon.stub();const p=sinon.stub();const i=sinon.stub();const m={STS:{getCallerIdentity:{ResponseMetadata:{RequestId:"ffffffff-ffff-ffff-ffff-ffffffffffff"},UserId:"XXXXXXXXXXXXXXXXXXXXX",Account:"999999999999",Arn:"arn:aws:iam::999999999999:user/test"}},ECR:{describeRepositories:{repositories:[{repositoryUri:l}]},getAuthorizationToken:{authorizationData:[{proxyEndpoint:d,authorizationToken:e}]}}};const c=sinon.stub().returns({stdBuffer:`digest: sha256:${n} size: 1787`});const f={"child-process-ext/spawn":c,"./lib/utils/telemetry/generatePayload.js":()=>({})};beforeEach(()=>{u.reset();p.reset();c.resetHistory()});it("should work correctly when repository exists beforehand",async()=>{const e={...m,ECR:{...m.ECR,describeRepositories:u.resolves({repositories:[{repositoryUri:l}]}),createRepository:p}};const{awsNaming:t,cfTemplate:s,fixtureData:{servicePath:r}}=await runServerless({fixture:"ecr",command:"package",awsRequestStubMap:e,modulesCacheStub:f});const a=t.getLambdaLogicalId("foo");const o=s.Resources[a].Properties;const i=g(s.Resources,a);expect(o.Code.ImageUri).to.deep.equal(`${l}@sha256:${n}`);expect(i.CodeSha256).to.equal(n);expect(u).to.be.calledOnce;expect(p.notCalled).to.be.true;expect(c).to.be.calledWith("docker",["--version"]);expect(c).not.to.be.calledWith("docker",["login","--username","AWS","--password","dockerauthtoken",d]);expect(c).to.be.calledWith("docker",["build","-t",`${t.getEcrRepositoryName()}:baseimage`,"-f",path.join(r,"Dockerfile"),"./"]);expect(c).to.be.calledWith("docker",["tag",`${t.getEcrRepositoryName()}:baseimage`,`${l}:baseimage`]);expect(c).to.be.calledWith("docker",["push",`${l}:baseimage`])});it("should work correctly when repository does not exist beforehand and scanOnPush is set",async()=>{const e={...m,ECR:{...m.ECR,describeRepositories:u.throws({providerError:{code:"RepositoryNotFoundException"}}),createRepository:i.resolves({repository:{repositoryUri:l}})}};const{awsNaming:t,cfTemplate:s}=await runServerless({fixture:"ecr",command:"package",awsRequestStubMap:e,modulesCacheStub:f,configExt:{provider:{ecr:{scanOnPush:true,images:{baseimage:{path:"./",file:"Dockerfile.dev"}}}}}});const r=t.getLambdaLogicalId("foo");const a=s.Resources[r].Properties;const o=g(s.Resources,r);expect(a.Code.ImageUri).to.deep.equal(`${l}@sha256:${n}`);expect(o.CodeSha256).to.equal(n);expect(u).to.be.calledOnce;expect(i).to.be.calledOnce;expect(i.args[0][0].imageScanningConfiguration).to.deep.equal({scanOnPush:true})});it("should work correctly when repository does not exist beforehand",async()=>{const e={...m,ECR:{...m.ECR,describeRepositories:u.throws({providerError:{code:"RepositoryNotFoundException"}}),createRepository:p.resolves({repository:{repositoryUri:l}})}};const{awsNaming:t,cfTemplate:s}=await runServerless({fixture:"ecr",command:"package",awsRequestStubMap:e,modulesCacheStub:f});const r=t.getLambdaLogicalId("foo");const a=s.Resources[r].Properties;const o=g(s.Resources,r);expect(a.Code.ImageUri).to.deep.equal(`${l}@sha256:${n}`);expect(o.CodeSha256).to.equal(n);expect(u).to.be.calledOnce;expect(p).to.be.calledOnce});it("should login and retry when docker push fails with no basic auth credentials error",async()=>{const e={...m,ECR:{...m.ECR,describeRepositories:u.resolves({repositories:[{repositoryUri:l}]}),createRepository:p}};const t=sinon.stub().returns({stdBuffer:`digest: sha256:${n} size: 1787`}).onCall(3).throws({stdBuffer:"no basic auth credentials"});const{awsNaming:s,cfTemplate:r,fixtureData:{servicePath:a}}=await runServerless({fixture:"ecr",command:"package",awsRequestStubMap:e,modulesCacheStub:{...f,"child-process-ext/spawn":t}});const o=s.getLambdaLogicalId("foo");const i=r.Resources[o].Properties;const c=g(r.Resources,o);expect(i.Code.ImageUri).to.deep.equal(`${l}@sha256:${n}`);expect(c.CodeSha256).to.equal(n);expect(u).to.be.calledOnce;expect(p.notCalled).to.be.true;expect(t).to.be.calledWith("docker",["--version"]);expect(t).to.be.calledWith("docker",["build","-t",`${s.getEcrRepositoryName()}:baseimage`,"-f",path.join(a,"Dockerfile"),"./"]);expect(t).to.be.calledWith("docker",["tag",`${s.getEcrRepositoryName()}:baseimage`,`${l}:baseimage`]);expect(t).to.be.calledWith("docker",["push",`${l}:baseimage`]);expect(t).to.be.calledWith("docker",["login","--username","AWS","--password","dockerauthtoken",d])});it("should login and retry when docker push fails with token has expired error",async()=>{const e={...m,ECR:{...m.ECR,describeRepositories:u.resolves({repositories:[{repositoryUri:l}]}),createRepository:p}};const t=sinon.stub().returns({stdBuffer:`digest: sha256:${n} size: 1787`}).onCall(3).throws({stdBuffer:"authorization token has expired"});await runServerless({fixture:"ecr",command:"package",awsRequestStubMap:e,modulesCacheStub:{...f,"child-process-ext/spawn":t}});expect(t).to.be.calledWith("docker",["push",`${l}:baseimage`]);expect(t).to.be.calledWith("docker",["login","--username","AWS","--password","dockerauthtoken",d])});it("should emit warning if docker login stores unencrypted credentials",async()=>{const e={...m,ECR:{...m.ECR,describeRepositories:u.resolves({repositories:[{repositoryUri:l}]}),createRepository:p}};const{stdoutData:t}=await runServerless({fixture:"ecr",command:"package",awsRequestStubMap:e,modulesCacheStub:{...f,"child-process-ext/spawn":sinon.stub().returns({stdBuffer:`digest: sha256:${n} size: 1787`}).onCall(3).throws({stdBuffer:"no basic auth credentials"}).onCall(4).returns({stdBuffer:"your password will be stored unencrypted"})}});expect(t).to.include("WARNING: Docker authentication token will be stored unencrypted in docker config.")});it("should work correctly when image is defined with implicit path in provider",async()=>{const e={...m,ECR:{...m.ECR,describeRepositories:u.resolves({repositories:[{repositoryUri:l}]}),createRepository:p}};const{awsNaming:t,cfTemplate:s}=await runServerless({fixture:"ecr",command:"package",awsRequestStubMap:e,modulesCacheStub:f,configExt:{provider:{ecr:{images:{baseimage:"./"}}}}});const r=t.getLambdaLogicalId("foo");const a=s.Resources[r].Properties;const o=Object.values(s.Resources).find(e=>e.Type==="AWS::Lambda::Version"&&e.Properties.FunctionName.Ref===r).Properties;expect(a.Code.ImageUri).to.deep.equal(`${l}@sha256:${n}`);expect(o.CodeSha256).to.equal(n);expect(u).to.be.calledOnce;expect(p.notCalled).to.be.true});it("should work correctly when image is defined with `file` set",async()=>{const e={...m,ECR:{...m.ECR,describeRepositories:u.resolves({repositories:[{repositoryUri:l}]}),createRepository:p}};const{awsNaming:t,cfTemplate:s,fixtureData:{servicePath:r}}=await runServerless({fixture:"ecr",command:"package",awsRequestStubMap:e,modulesCacheStub:f,configExt:{provider:{ecr:{images:{baseimage:{path:"./",file:"Dockerfile.dev"}}}}}});const a=t.getLambdaLogicalId("foo");const o=s.Resources[a].Properties;const i=Object.values(s.Resources).find(e=>e.Type==="AWS::Lambda::Version"&&e.Properties.FunctionName.Ref===a).Properties;expect(o.Code.ImageUri).to.deep.equal(`${l}@sha256:${n}`);expect(i.CodeSha256).to.equal(n);expect(u).to.be.calledOnce;expect(p.notCalled).to.be.true;expect(c).to.be.calledWith("docker",["build","-t",`${t.getEcrRepositoryName()}:baseimage`,"-f",path.join(r,"Dockerfile.dev"),"./"])});it("should work correctly when image is defined with `cacheFrom` set",async()=>{const e={...m,ECR:{...m.ECR,describeRepositories:u.resolves({repositories:[{repositoryUri:l}]}),createRepository:p}};const{awsNaming:t,cfTemplate:s,fixtureData:{servicePath:r}}=await runServerless({fixture:"ecr",command:"package",awsRequestStubMap:e,modulesCacheStub:f,configExt:{provider:{ecr:{images:{baseimage:{path:"./",file:"Dockerfile.dev",cacheFrom:["my-image:latest"]}}}}}});const a=t.getLambdaLogicalId("foo");const o=s.Resources[a].Properties;const i=Object.values(s.Resources).find(e=>e.Type==="AWS::Lambda::Version"&&e.Properties.FunctionName.Ref===a).Properties;expect(o.Code.ImageUri).to.deep.equal(`${l}@sha256:${n}`);expect(i.CodeSha256).to.equal(n);expect(u).to.be.calledOnce;expect(p.notCalled).to.be.true;expect(c).to.be.calledWith("docker",["build","-t",`${t.getEcrRepositoryName()}:baseimage`,"-f",path.join(r,"Dockerfile.dev"),"--cache-from","my-image:latest","./"])});it("should work correctly when image is defined with `buildArgs` set",async()=>{const e={...m,ECR:{...m.ECR,describeRepositories:u.resolves({repositories:[{repositoryUri:l}]}),createRepository:p}};const{awsNaming:t,cfTemplate:s,fixtureData:{servicePath:r}}=await runServerless({fixture:"ecr",command:"package",awsRequestStubMap:e,modulesCacheStub:f,configExt:{provider:{ecr:{images:{baseimage:{path:"./",file:"Dockerfile.dev",buildArgs:{TESTKEY:"TESTVAL"}}}}}}});const a=t.getLambdaLogicalId("foo");const o=s.Resources[a].Properties;const i=Object.values(s.Resources).find(e=>e.Type==="AWS::Lambda::Version"&&e.Properties.FunctionName.Ref===a).Properties;expect(o.Code.ImageUri).to.deep.equal(`${l}@sha256:${n}`);expect(i.CodeSha256).to.equal(n);expect(u).to.be.calledOnce;expect(p.notCalled).to.be.true;expect(c).to.be.calledWith("docker",["build","-t",`${t.getEcrRepositoryName()}:baseimage`,"-f",path.join(r,"Dockerfile.dev"),"--build-arg","TESTKEY=TESTVAL","./"])});it("should work correctly when `functions[].image` is defined with explicit name",async()=>{const e={...m,ECR:{...m.ECR,describeRepositories:u.resolves({repositories:[{repositoryUri:l}]}),createRepository:p}};const{awsNaming:t,cfTemplate:s}=await runServerless({fixture:"ecr",command:"package",awsRequestStubMap:e,modulesCacheStub:f,configExt:{provider:{ecr:{images:{baseimage:"./"}}},functions:{foo:{image:{name:"baseimage"}}}}});const r=t.getLambdaLogicalId("foo");const a=s.Resources[r].Properties;const o=g(s.Resources,r);expect(a.Code.ImageUri).to.deep.equal(`${l}@sha256:${n}`);expect(o.CodeSha256).to.equal(n)});it("should fail when docker command is not available",async()=>{await expect(runServerless({fixture:"ecr",command:"package",awsRequestStubMap:m,modulesCacheStub:{"child-process-ext/spawn":sinon.stub().throws()}})).to.be.eventually.rejected.and.have.property("code","DOCKER_COMMAND_NOT_AVAILABLE")});it("should fail when docker build fails",async()=>{await expect(runServerless({fixture:"ecr",command:"package",awsRequestStubMap:m,modulesCacheStub:{...f,"child-process-ext/spawn":sinon.stub().returns({}).onSecondCall().throws()}})).to.be.eventually.rejected.and.have.property("code","DOCKER_BUILD_ERROR")});it("should fail when docker tag fails",async()=>{await expect(runServerless({fixture:"ecr",command:"package",awsRequestStubMap:m,modulesCacheStub:{...f,"child-process-ext/spawn":sinon.stub().returns({}).onCall(2).throws()}})).to.be.eventually.rejected.and.have.property("code","DOCKER_TAG_ERROR")});it("should fail when docker push fails",async()=>{await expect(runServerless({fixture:"ecr",command:"package",awsRequestStubMap:m,modulesCacheStub:{...f,"child-process-ext/spawn":sinon.stub().returns({}).onCall(3).throws()}})).to.be.eventually.rejected.and.have.property("code","DOCKER_PUSH_ERROR")});it("should fail when docker login fails",async()=>{await expect(runServerless({fixture:"ecr",command:"package",awsRequestStubMap:m,modulesCacheStub:{...f,"child-process-ext/spawn":sinon.stub().returns({}).onCall(3).throws({stdBuffer:"no basic auth credentials"}).onCall(4).throws()}})).to.be.eventually.rejected.and.have.property("code","DOCKER_LOGIN_ERROR")})})})});