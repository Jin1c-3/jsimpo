"use strict";const common=require("../common");const fixtures=require("../common/fixtures");if(!common.hasCrypto)common.skip("missing crypto");process.env.NODE_TLS_REJECT_UNAUTHORIZED="0";common.expectWarning("Warning","Setting the NODE_TLS_REJECT_UNAUTHORIZED environment variable to '0' "+"makes TLS connections and HTTPS requests insecure by disabling "+"certificate verification.");const assert=require("assert");const https=require("https");function read(e){return fixtures.readKey(e)}const key1=read("agent1-key.pem");const cert1=read("agent1-cert.pem");const key2=read("agent2-key.pem");const cert2=read("agent2-cert.pem");const key3=read("agent3-key.pem");const cert3=read("agent3-cert.pem");const ca1=read("ca1-cert.pem");const ca2=read("ca2-cert.pem");const agent0=new https.Agent;const agent1=new https.Agent({ca:[ca1]});const agent2=new https.Agent({ca:[ca2]});const agent3=new https.Agent({ca:[ca1,ca2]});const options1={key:key1,cert:cert1};const options2={key:key2,cert:cert2};const options3={key:key3,cert:cert3};const server1=server(options1);const server2=server(options2);const server3=server(options3);let listenWait=0;server1.listen(0,listening());server2.listen(0,listening());server3.listen(0,listening());const responseErrors={};let pending=0;function server(e){const t=https.createServer(e,handler);t.requests=[];t.expectCount=0;return t}function handler(e,t){this.requests.push(e.url);t.statusCode=200;t.setHeader("foo","bar");t.end("hello, world\n")}function listening(){listenWait++;return()=>{listenWait--;if(listenWait===0){allListening()}}}function makeReq(t,e,n,r,s){pending++;const a={port:e,path:t,ca:s};if(!s){a.agent=agent0}else{if(!Array.isArray(s))s=[s];if(s.includes(ca1)&&s.includes(ca2)){a.agent=agent3}else if(s.includes(ca1)){a.agent=agent1}else if(s.includes(ca2)){a.agent=agent2}else{a.agent=agent0}}if(r){a.headers={host:r}}const c=https.get(a);const o=e===server1.address().port?server1:e===server2.address().port?server2:e===server3.address().port?server3:null;if(!o)throw new Error(`invalid port: ${e}`);o.expectCount++;c.on("response",common.mustCall(e=>{assert.strictEqual(e.connection.authorizationError,n);responseErrors[t]=e.connection.authorizationError;pending--;if(pending===0){server1.close();server2.close();server3.close()}e.resume()}))}function allListening(){const e=server1.address().port;const t=server2.address().port;const n=server3.address().port;makeReq("/inv1",e,"UNABLE_TO_VERIFY_LEAF_SIGNATURE");makeReq("/inv1-ca1",e,"ERR_TLS_CERT_ALTNAME_INVALID",null,ca1);makeReq("/inv1-ca1ca2",e,"ERR_TLS_CERT_ALTNAME_INVALID",null,[ca1,ca2]);makeReq("/val1-ca1",e,null,"agent1",ca1);makeReq("/val1-ca1ca2",e,null,"agent1",[ca1,ca2]);makeReq("/inv1-ca2",e,"UNABLE_TO_VERIFY_LEAF_SIGNATURE","agent1",ca2);makeReq("/inv2",t,"DEPTH_ZERO_SELF_SIGNED_CERT");makeReq("/inv2-ca1",t,"DEPTH_ZERO_SELF_SIGNED_CERT","agent2",ca1);makeReq("/inv2-ca1ca2",t,"DEPTH_ZERO_SELF_SIGNED_CERT","agent2",[ca1,ca2]);makeReq("/inv3",n,"UNABLE_TO_VERIFY_LEAF_SIGNATURE");makeReq("/inv3-ca2",n,"ERR_TLS_CERT_ALTNAME_INVALID",null,ca2);makeReq("/inv3-ca1ca2",n,"ERR_TLS_CERT_ALTNAME_INVALID",null,[ca1,ca2]);makeReq("/val3-ca2",n,null,"agent3",ca2);makeReq("/val3-ca1ca2",n,null,"agent3",[ca1,ca2]);makeReq("/inv3-ca1",n,"UNABLE_TO_VERIFY_LEAF_SIGNATURE","agent1",ca1)}process.on("exit",()=>{assert.strictEqual(server1.requests.length,server1.expectCount);assert.strictEqual(server2.requests.length,server2.expectCount);assert.strictEqual(server3.requests.length,server3.expectCount)});