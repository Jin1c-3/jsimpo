import{$appendChild,$getChildrenByClass,$getChildrenByName,$getParent,$namespaceId,XFAObject,XFAObjectArray,XmlObject}from"./xfa_object.js";import{warn}from"../../shared/util.js";const namePattern=/^[^.[]+/;const indexPattern=/^[^\]]+/;const operators={dot:0,dotDot:1,dotHash:2,dotBracket:3,dotParen:4};const shortcuts=new Map([["$data",(e,t)=>e.datasets.data],["$template",(e,t)=>e.template],["$connectionSet",(e,t)=>e.connectionSet],["$form",(e,t)=>e.form],["$layout",(e,t)=>e.layout],["$host",(e,t)=>e.host],["$dataWindow",(e,t)=>e.dataWindow],["$event",(e,t)=>e.event],["!",(e,t)=>e.datasets],["$xfa",(e,t)=>e],["xfa",(e,t)=>e],["$",(e,t)=>t]]);const somCache=new WeakMap;function parseIndex(e){e=e.trim();if(e==="*"){return Infinity}return parseInt(e,10)||0}function parseExpression(t,n,r=true){let a=t.match(namePattern);if(!a){return null}let[o]=a;const s=[{name:o,cacheName:"."+o,index:0,js:null,formCalc:null,operator:operators.dot}];let i=o.length;while(i<t.length){const l=i;const c=t.charAt(i++);if(c==="["){a=t.slice(i).match(indexPattern);if(!a){warn("XFA - Invalid index in SOM expression");return null}s[s.length-1].index=parseIndex(a[0]);i+=a[0].length+1;continue}let e;switch(t.charAt(i)){case".":if(!n){return null}i++;e=operators.dotDot;break;case"#":i++;e=operators.dotHash;break;case"[":if(r){warn("XFA - SOM expression contains a FormCalc subexpression which is not supported for now.");return null}e=operators.dotBracket;break;case"(":if(r){warn("XFA - SOM expression contains a JavaScript subexpression which is not supported for now.");return null}e=operators.dotParen;break;default:e=operators.dot;break}a=t.slice(i).match(namePattern);if(!a){break}[o]=a;i+=o.length;s.push({name:o,cacheName:t.slice(l,i),operator:e,index:0,js:null,formCalc:null})}return s}function searchNode(t,n,e,r=true,a=true){const o=parseExpression(e,r);if(!o){return null}const s=shortcuts.get(o[0].name);let i=0;let l;if(s){l=true;t=[s(t,n)];i=1}else{l=n===null;t=[n||t]}for(let e=o.length;i<e;i++){const{name:c,cacheName:d,operator:u,index:f}=o[i];const h=[];for(const p of t){if(!(p instanceof XFAObject)){continue}let e,t;if(a){t=somCache.get(p);if(!t){t=new Map;somCache.set(p,t)}e=t.get(d)}if(!e){switch(u){case operators.dot:e=p[$getChildrenByName](c,false);break;case operators.dotDot:e=p[$getChildrenByName](c,true);break;case operators.dotHash:e=p[$getChildrenByClass](c);if(e instanceof XFAObjectArray){e=e.children}else{e=[e]}break;default:break}if(a){t.set(d,e)}}if(e.length>0){h.push(e)}}if(h.length===0&&!l&&i===0){const m=n[$getParent]();n=m;if(!n){return null}i=-1;t=[n];continue}if(isFinite(f)){t=h.filter(e=>f<e.length).map(e=>e[f])}else{t=h.reduce((e,t)=>e.concat(t),[])}}if(t.length===0){return null}return t}function createNodes(n,e){let r=null;for(const{name:a,index:o}of e){for(let e=0,t=!isFinite(o)?0:o;e<=t;e++){r=new XmlObject(n[$namespaceId],a);n[$appendChild](r)}n=r}return r}function createDataNode(t,e,n){const r=parseExpression(n);if(!r){return null}if(r.some(e=>e.operator===operators.dotDot)){return null}const a=shortcuts.get(r[0].name);let o=0;if(a){t=a(t,e);o=1}else{t=e||t}for(let e=r.length;o<e;o++){const{name:s,operator:i,index:l}=r[o];if(!isFinite(l)){r[o].index=0;return createNodes(t,r.slice(o))}let e;switch(i){case operators.dot:e=t[$getChildrenByName](s,false);break;case operators.dotDot:e=t[$getChildrenByName](s,true);break;case operators.dotHash:e=t[$getChildrenByClass](s);if(e instanceof XFAObjectArray){e=e.children}else{e=[e]}break;default:break}if(e.length===0){return createNodes(t,r.slice(o))}if(l<e.length){const c=e[l];if(!(c instanceof XFAObject)){warn(`XFA - Cannot create a node.`);return null}t=c}else{r[o].index=l-e.length;return createNodes(t,r.slice(o))}}return null}export{createDataNode,searchNode};