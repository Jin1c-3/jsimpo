"use strict";const npa=require("npm-package-arg");const path=require("path");const loadJsonFile=require("load-json-file");const writePkg=require("write-pkg");const PKG=Symbol("pkg");const _location=Symbol("location");const _resolved=Symbol("resolved");const _rootPath=Symbol("rootPath");const _scripts=Symbol("scripts");const _contents=Symbol("contents");function binSafeName({name:e,scope:t}){return t?e.substring(t.length+1):e}function shallowCopy(i){return Object.keys(i).reduce((e,t)=>{const n=i[t];if(Array.isArray(n)){e[t]=n.slice()}else if(n&&typeof n==="object"){e[t]=Object.assign({},n)}else{e[t]=n}return e},{})}class Package{static lazy(e,t="."){if(typeof e==="string"){const n=path.resolve(path.basename(e)==="package.json"?path.dirname(e):e);const i=loadJsonFile.sync(path.join(n,"package.json"));return new Package(i,n)}if("__isLernaPackage"in e){return e}return new Package(e,t)}constructor(e,t,n=t){const i=npa.resolve(e.name,`file:${path.relative(n,t)}`,n);this.name=e.name;this[PKG]=e;Object.defineProperty(this,PKG,{enumerable:false,writable:true});this[_location]=t;this[_resolved]=i;this[_rootPath]=n;this[_scripts]={...e.scripts}}get location(){return this[_location]}get private(){return Boolean(this[PKG].private)}get resolved(){return this[_resolved]}get rootPath(){return this[_rootPath]}get scripts(){return this[_scripts]}get bin(){const e=this[PKG];return typeof e.bin==="string"?{[binSafeName(this.resolved)]:e.bin}:Object.assign({},e.bin)}get binLocation(){return path.join(this.location,"node_modules",".bin")}get manifestLocation(){return path.join(this.location,"package.json")}get nodeModulesLocation(){return path.join(this.location,"node_modules")}get __isLernaPackage(){return true}get version(){return this[PKG].version}set version(e){this[PKG].version=e}get contents(){if(this[_contents]){return this[_contents]}if(this[PKG].publishConfig&&this[PKG].publishConfig.directory){return path.join(this.location,this[PKG].publishConfig.directory)}return this.location}set contents(e){this[_contents]=path.join(this.location,e)}get dependencies(){return this[PKG].dependencies}get devDependencies(){return this[PKG].devDependencies}get optionalDependencies(){return this[PKG].optionalDependencies}get peerDependencies(){return this[PKG].peerDependencies}get(e){return this[PKG][e]}set(e,t){this[PKG][e]=t;return this}toJSON(){return shallowCopy(this[PKG])}refresh(){return loadJsonFile(this.manifestLocation).then(e=>{this[PKG]=e;return this})}serialize(){return writePkg(this.manifestLocation,this[PKG]).then(()=>this)}updateLocalDependency(e,t,n){const i=e.name;let s=this.dependencies;if(!s||!s[i]){s=this.optionalDependencies}if(!s||!s[i]){s=this.devDependencies}if(e.registry||e.type==="directory"){s[i]=`${n}${t}`}else if(e.gitCommittish){const[o]=/^\D*/.exec(e.gitCommittish);const{hosted:r}=e;r.committish=`${o}${t}`;s[i]=r.toString({noGitPlus:false,noCommittish:false})}else if(e.gitRange){const{hosted:r}=e;r.committish=`semver:${n}${t}`;s[i]=r.toString({noGitPlus:false,noCommittish:false})}}}module.exports.Package=Package;