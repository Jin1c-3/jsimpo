import createWorker from"./worker-executor";function mockWorker({init:e,postMessage:t,terminate:s}={}){global.Worker=jest.fn(function(){setImmediate(e&&e(this)||(()=>this.onmessage&&this.onmessage({data:{type:"contentLoaded"}})));this.onmessage=null;this.postMessage=t||function(e){setImmediate(()=>this.onmessage&&this.onmessage({data:`${e} processed`}))};this.terminate=s||(()=>{});return this})}afterEach(()=>{delete global.Worker});it("Worker executor should successfully execute one task",async()=>{const e=jest.fn();mockWorker({terminate:e});const t=createWorker("test");expect(t).not.toBeUndefined();const s=t.execute("test");expect(s).not.toBeUndefined();expect(s.done).not.toBeUndefined();const o=jest.fn();s.on("done",o);const c=jest.fn();s.on("error",c);await expect(s.done).resolves.toBe("test processed");expect(o).toBeCalledTimes(1);expect(o).toBeCalledWith("test processed");expect(c).not.toBeCalled();expect(e).not.toBeCalled();expect(global.Worker).toBeCalledTimes(1);expect(global.Worker).toBeCalledWith("/js/test.js")});it("Worker executor should successfully execute two tasks in parallel",async()=>{const e=jest.fn();mockWorker({terminate:e});const t=createWorker("test");const s=t.execute("test1");const o=jest.fn();s.on("done",o);const c=jest.fn();s.on("error",c);const r=t.execute("test2");const n=jest.fn();r.on("done",n);const a=jest.fn();r.on("error",a);await expect(Promise.all([s.done,r.done])).resolves.toEqual(["test1 processed","test2 processed"]);expect(o).toBeCalledTimes(1);expect(o).toBeCalledWith("test1 processed");expect(c).not.toBeCalled();expect(n).toBeCalledTimes(1);expect(n).toBeCalledWith("test2 processed");expect(a).not.toBeCalled();expect(e).not.toBeCalled();expect(global.Worker).toBeCalledTimes(2)});it("Worker executor should successfully execute 3 tasks in parallel and use two workers",async()=>{mockWorker();const e=createWorker("test");const t=e.execute("test1");const s=e.execute("test2");const o=e.execute("test3");await expect(Promise.all([t.done,s.done,o.done])).resolves.toEqual(["test1 processed","test2 processed","test3 processed"]);expect(global.Worker).toBeCalledTimes(2)});it("Worker executor should successfully execute 3 tasks, use 3 workers and terminate each worker",async()=>{const e=jest.fn();mockWorker({terminate:e});const t=createWorker("test",{terminateWorker:true});const s=t.execute("test1");const o=t.execute("test2");const c=t.execute("test3");await expect(Promise.all([s.done,o.done,c.done])).resolves.toEqual(["test1 processed","test2 processed","test3 processed"]);expect(e).toBeCalledTimes(3);expect(global.Worker).toBeCalledTimes(3)});it("Worker executor should successfully execute 3 tasks in parallel and use 3 workers",async()=>{mockWorker();const e=createWorker("test",{concurrency:3});const t=e.execute("test1");const s=e.execute("test2");const o=e.execute("test3");await expect(Promise.all([t.done,s.done,o.done])).resolves.toEqual(["test1 processed","test2 processed","test3 processed"]);expect(global.Worker).toBeCalledTimes(3)});it("Worker executor should successfully execute 3 tasks and use 1 worker",async()=>{mockWorker();const e=createWorker("test",{concurrency:1});const t=e.execute("test1");const s=e.execute("test2");const o=e.execute("test3");await expect(Promise.all([t.done,s.done,o.done])).resolves.toEqual(["test1 processed","test2 processed","test3 processed"]);expect(global.Worker).toBeCalledTimes(1)});it("Worker executor should reject task",async()=>{const e={message:"Error on init worker"};mockWorker({init:()=>{throw e}});const t=createWorker("test");const s=t.execute("test");const o=jest.fn();s.on("error",o);await expect(s.done).rejects.toBe(e.message);expect(o).toBeCalledTimes(1);expect(o).toBeCalledWith(e)});it("Worker executor should emit LOG events",async()=>{mockWorker({postMessage:function(e){setImmediate(()=>{for(let e=0;e<3;e++){this.onmessage&&this.onmessage({data:{type:"LOG",data:e}})}this.onmessage&&this.onmessage({data:`${e} processed`});setImmediate(()=>this.onmessage&&this.onmessage({data:{type:"LOG",data:3}}))})}});const e=createWorker("test");const t=e.execute("test");const s=jest.fn();t.on("done",s);const o=jest.fn();t.on("error",o);const c=jest.fn();t.on("LOG",c);await expect(t.done).resolves.toBe("test processed");expect(s).toBeCalledTimes(1);expect(s).toBeCalledWith("test processed");expect(o).not.toBeCalled();expect(c).toBeCalledTimes(3);for(let e=0;e<3;e++){expect(c.mock.calls[e][0]).toBe(e)}});it("Worker executor should reject task on timeout",async()=>{const e=jest.fn();mockWorker({postMessage:()=>{},terminate:e});const t=createWorker("test");const s=t.execute("test",0);const o=jest.fn();s.on("error",o);await expect(s.done).rejects.toBe("timeout");expect(o).toBeCalledTimes(1);expect(o.mock.calls[0][0]).toEqual({message:"timeout"});expect(e).toBeCalledTimes(1)});it("Worker executor should get worker from specified location",async()=>{mockWorker();const e=createWorker("test",{location:"/other/location/"});const t=e.execute("test");await expect(t.done).resolves.toBe("test processed");expect(global.Worker).toBeCalledTimes(1);expect(global.Worker).toBeCalledWith("/other/location/test.js")});