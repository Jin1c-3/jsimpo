"use strict";const{ConcatSource}=require("webpack-sources");const extractFragmentIndex=(t,e)=>[t,e];const sortFragmentWithIndex=([t,e],[n,r])=>{const o=t.stage-n.stage;if(o!==0)return o;const s=t.position-n.position;if(s!==0)return s;return e-r};class InitFragment{constructor(t,e,n,r,o){this.content=t;this.stage=e;this.position=n;this.key=r;this.endContent=o}getContent(t){return this.content}getEndContent(t){return this.endContent}static addToSource(t,e,n){if(e.length>0){const r=e.map(extractFragmentIndex).sort(sortFragmentWithIndex);const o=new Map;for(const[a]of r){if(typeof a.mergeAll==="function"){if(!a.key){throw new Error(`InitFragment with mergeAll function must have a valid key: ${a.constructor.name}`)}const c=o.get(a.key);if(c===undefined){o.set(a.key,a)}else if(Array.isArray(c)){c.push(a)}else{o.set(a.key,[c,a])}continue}else if(typeof a.merge==="function"){const c=o.get(a.key);if(c!==undefined){o.set(a.key,a.merge(c));continue}}o.set(a.key||Symbol(),a)}const s=new ConcatSource;const i=[];for(let t of o.values()){if(Array.isArray(t)){t=t[0].mergeAll(t)}s.add(t.getContent(n));const g=t.getEndContent(n);if(g){i.push(g)}}s.add(t);for(const u of i.reverse()){s.add(u)}return s}else{return t}}}InitFragment.prototype.merge=undefined;InitFragment.STAGE_CONSTANTS=10;InitFragment.STAGE_ASYNC_BOUNDARY=20;InitFragment.STAGE_HARMONY_EXPORTS=30;InitFragment.STAGE_HARMONY_IMPORTS=40;InitFragment.STAGE_PROVIDES=50;InitFragment.STAGE_ASYNC_DEPENDENCIES=60;InitFragment.STAGE_ASYNC_HARMONY_IMPORTS=70;module.exports=InitFragment;