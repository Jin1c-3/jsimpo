import{Meteor}from"meteor/meteor";import{Accounts}from"meteor/accounts-base";import{Template}from"meteor/templating";import{Tracker}from"meteor/tracker";import _ from"underscore";import mem from"mem";import{APIClient}from"../../utils/client";import{saveUser,interestedUserIds}from"../../../client/startup/listenActiveUsers";import{Presence}from"../../../client/lib/presence";import"./userPresence.html";const data=new Map;const promises=new Map;const pending=new Map;const getAll=_.debounce(async function e(){const t=Array.from(pending.keys());if(t.length===0){return}const r={ids:t};try{const{users:s}=await APIClient.v1.get("users.presence",r);s.forEach(e=>saveUser(e,true));t.forEach(e=>{const{resolve:t}=promises.get(e);t()})}catch(e){t.forEach(e=>{const{reject:t}=promises.get(e);t()})}},100);export const get=mem(function e(r){interestedUserIds.add(r);const t=pending.get(r)||new Promise((e,t)=>{promises.set(r,{resolve:e,reject:t})});pending.set(r,t);return t});const options={threshold:.1};let lastEntries=[];const handleEntries=function(e){lastEntries=e.filter(({isIntersecting:e})=>e);lastEntries.forEach(async e=>{const{uid:t}=data.get(e.target);await get(t);pending.delete(t)});getAll()};const featureExists=!!window.IntersectionObserver;const observer=featureExists&&new IntersectionObserver(handleEntries,options);Tracker.autorun(()=>{const e=Meteor.status().connected;if(!Meteor.userId()||!e){Presence.reset();return Meteor.users.update({status:{$exists:true}},{$unset:{status:true}},{multi:true})}mem.clear(get);Presence.restart();if(featureExists){for(const t of data.keys()){observer.unobserve(t);observer.observe(t)}return}getAll();Accounts.onLogout(()=>{Presence.reset();interestedUserIds.clear()})});Template.userPresence.onRendered(function(){if(!this.data||!this.data.uid){return}data.set(this.firstNode,this.data);if(featureExists){return observer.observe(this.firstNode)}});